<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    

    <title>GCC Inline ASM | Axiomaster&#39;s Site</title>
    <meta property="og:title" content="GCC Inline ASM - Axiomaster&#39;s Site">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2021-10-31T21:05:29&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2021-10-31T21:05:29&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="GCC Inline ASM">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://axiomaster.gitee.io/post/2021-10-31-gcc-inline-asm/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://axiomaster.gitee.io/">
                        Axiomaster&#39;s Site
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://axiomaster.gitee.io/">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">GCC Inline ASM</h1>
        </header>
        <date class="post-meta meta-date">
            2021年10月31日
        </date>
        
        
        
        <div class="post-content">
            <p>GCC 支持在C/C++代码中嵌入汇编代码，这些汇编代码被称作GCC Inline ASM——GCC内联汇编。这是一个非常有用的功能，有利于我们将一些C/C++语法无法表达指令直接潜入C/C++代码中，另外也允许我们直接写 C/C++代码中使用汇编编写简洁高效的代码。</p>
<h2 id="1基本内联汇编">1.基本内联汇编</h2>
<p>GCC中基本的内联汇编非常易懂，我们先来看两个简单的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__(<span style="color:#e6db74">&#34;movl %esp,%eax&#34;</span>); <span style="color:#75715e">// 看起来很熟悉吧！
</span></code></pre></div><p>或者是</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__(<span style="color:#e6db74">&#34;movl $1,%eax // SYS_exitxor %ebx,%ebxint $0x80&#34;</span>);
</code></pre></div><p>或</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__(<span style="color:#e6db74">&#34;movl $1,%eax/r/t&#34;</span> <span style="color:#f92672">/</span><span style="color:#e6db74">&#34;xor %ebx,%ebx/r/t&#34;</span> <span style="color:#f92672">/</span><span style="color:#e6db74">&#34;int $0x80&#34;</span> <span style="color:#f92672">/</span>);
</code></pre></div><h2 id="2基本内联汇编的格式">2.基本内联汇编的格式</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__ <span style="color:#a6e22e">__volatile__</span>(<span style="color:#e6db74">&#34;Instruction List&#34;</span>);
</code></pre></div><h3 id="1__asm__">1、<strong>asm</strong></h3>
<p>__asm__是GCC关键字asm的宏定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define __asm__ asm
</span></code></pre></div><p><code>__asm__</code>或<code>asm</code>用来声明一个内联汇编表达式，所以任何一个内联汇编表达式都是以它开头的，是必不可少的。</p>
<h3 id="2instruction-list">2、Instruction List</h3>
<p>Instruction List是汇编指令序列。它可以是空的，比如：<code>__asm__ __volatile__(&quot;&quot;);</code> 或 <code>__asm__ (&quot;&quot;);</code> 都是完全合法的内联汇编表达式，只不过这两条语句没有什么意义。</p>
<p>但并非所有Instruction List为空的内联汇编表达式都是没有意义的，比如： <code>__asm__ (&quot;&quot;:::&quot;memory&quot;);</code> 就非常有意义，它向GCC声明：“我对内存作了改动”，GCC在编译的时候，会将此因素考虑进去。</p>
<p>我们看一看下面这个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat example1.c

int main<span style="color:#f92672">(</span>int __argc, char* __argv<span style="color:#f92672">[])</span>
<span style="color:#f92672">{</span>
    int* __p <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>int*<span style="color:#f92672">)</span>__argc;
    <span style="color:#f92672">(</span>*__p<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> 9999;

    //__asm__<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;&#34;</span>:::<span style="color:#e6db74">&#34;memory&#34;</span><span style="color:#f92672">)</span>;

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>*__p<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 9999<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> 5;
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>*__p<span style="color:#f92672">)</span>;
<span style="color:#f92672">}</span>
</code></pre></div><p>在这段代码中，那条内联汇编是被注释掉的。在这条内联汇编之前，内存指针__p所指向的内存被赋值为9999，随即在内联汇编之后，一条if语句判断__p 所指向的内存与9999是否相等。很明显，它们是相等的。GCC在优化编译的时候能够很聪明的发现这一点。我们使用下面的命令行对其进行编译：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gcc -O -S example1.c
</code></pre></div><p>选项-O表示优化编译，我们还可以指定优化等级，比如-O2表示优化等级为2；选项-S表示将C/C++源文件编译为汇编文件，文件名和C/C++文件一样，只不过扩展名由.c变为.s。</p>
<p>我们来查看一下被放在example1.s中的编译结果，我们这里仅仅列出了使用gcc 2.96在redhat 7.3上编译后的相关函数部分汇编代码。为了保持清晰性，无关的其它代码未被列出。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat example1.s 

main: 
    pushl %ebp 
    movl %esp, %ebp 
    movl 8<span style="color:#f92672">(</span>%ebp<span style="color:#f92672">)</span>, %eax <span style="color:#75715e"># int* __p = (int*)__argc</span>
    movl $9999, <span style="color:#f92672">(</span>%eax<span style="color:#f92672">)</span> <span style="color:#75715e"># (*__p) = 9999</span> 
    movl $5, %eax <span style="color:#75715e"># return 5</span>
    popl %ebp ret
</code></pre></div><p>参照一下C源码和编译出的汇编代码，我们会发现汇编代码中，没有if语句相关的代码，而是在赋值语句<code>(*__p)=9999</code>后直接<code>return 5</code>；这是因为GCC认为在<code>(*__p)</code>被赋值之后，在if语句之前没有任何改变<code>(*__p)</code>内容的操作，所以那条if语句的判断条件<code>(*__p) == 9999</code>肯定是为true的，所以GCC就不再生成相关代码，而是直接根据为true的条件生成return 5的汇编代码（GCC使用eax作为保存返回值的寄存器）。</p>
<p>我们现在将example1.c中内联汇编的注释去掉，重新编译，然后看一下相关的编译结果。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#960050;background-color:#1e0010">$</span> gcc <span style="color:#f92672">-</span>O <span style="color:#f92672">-</span>S example1.c
<span style="color:#960050;background-color:#1e0010">$</span> cat example1.s

main: 
    pushl <span style="color:#f92672">%</span>ebp 
    movl <span style="color:#f92672">%</span>esp, <span style="color:#f92672">%</span>ebp 
    movl <span style="color:#ae81ff">8</span>(<span style="color:#f92672">%</span>ebp), <span style="color:#f92672">%</span>eax <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> __p <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>)__argc
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">9999</span>, (<span style="color:#f92672">%</span>eax) <span style="color:#960050;background-color:#1e0010">#</span> (<span style="color:#f92672">*</span>__p) <span style="color:#f92672">=</span> <span style="color:#ae81ff">9999</span>
    <span style="color:#75715e">#APP # __asm__(&#34;&#34;:::&#34;memory&#34;)
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#NO_APP
</span><span style="color:#75715e"></span>    cmpl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">9999</span>, (<span style="color:#f92672">%</span>eax) <span style="color:#960050;background-color:#1e0010">#</span> (<span style="color:#f92672">*</span>__p) <span style="color:#f92672">==</span> <span style="color:#ae81ff">9999</span> <span style="color:#f92672">?</span>
    jne .L3 <span style="color:#960050;background-color:#1e0010">#</span> false 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">5</span>, <span style="color:#f92672">%</span>eax <span style="color:#960050;background-color:#1e0010">#</span> true, 
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">5</span> 
    jmp .L2 
    .p2
    align <span style="color:#ae81ff">2</span> 
    .L3: 
    movl (<span style="color:#f92672">%</span>eax), <span style="color:#f92672">%</span>eax 
    .L2: 
    popl <span style="color:#f92672">%</span>ebp 
    ret
</code></pre></div><p>由于内联汇编语句<code>__asm__(&quot;&quot;:::&quot;memory&quot;)</code>向GCC声明，在此内联汇编语句出现的位置内存内容可能了改变，所以GCC在编译时就不能像刚才那样处理。这次，GCC老老实实的将if语句生成了汇编代码。</p>
<p>可能有人会质疑：为什么要使用<code>__asm__(&quot;&quot;:::&quot;memory&quot;)</code>向GCC声明内存发生了变化？明明“Instruction  List”是空的，没有任何对内存的操作，这样做只增加GCC生成汇编代码的数量。</p>
<p>确实，那条内联汇编语句没有对内存作任何操作，事实上它确实什么都没有做。但影响内存内容的不仅仅是你当前正在运行的程序。比如，如果你现在正在操作的存是一块内存映射，映射的内容是外围I/O设备寄存器。那么操作这块内存的就不仅仅是当前的程序，I/O设备也会去操作这块内存。既然两者都会去操作同一块存，那么任何一方在任何时候都不能对这块内存的内容想当然。所以当你使用高级语言C/C++写这类程序的时候，你必须让编译器也能够明白这一点，毕竟高级语最终要被编译为汇编代码。</p>
<p>你可能已经注意到了，这次输出的汇编结果中，有两个符号：<code>#APP</code>和<code>#NO_APP</code>，GCC将内联汇编语句中&quot;Instruction  List&quot;所列出的指令放在<code>#APP</code>和<code>#NO_APP</code>间，由于<code>__asm__(&quot;&quot;:::&quot;memory&quot;)</code>中“Instruction List”为空，所以<code>#APP</code>和<code>#NO_APP</code>中间也没有任何内容。但我们以后的例子会更加清楚的表现这一点。</p>
<p>关于为什么内联汇编<code>__asm__(&quot;&quot;:::&quot;memory&quot;)</code>是一条声明内存改变的语句，我们后面会详细讨论。刚才我们花了大量的内容来讨论&quot;Instruction  List&quot;为空的情况，但在实际的编程中，&ldquo;Instruction List&quot;绝大多数情况下都不是空的。它可以有1条或任意多条汇编指令。</p>
<p>当在&quot;Instruction List&quot;中有多条指令的时候，你可以在一对引号中列出全部指令，也可以将一条或几条指令放在一对引号中，所有指令放在多对引号中。如果是前者，你可以将每一条指令放在一行，如果要将多条指令放在一行，则必须用分号（<code>;</code>）或换行符（<code>/n</code>，大多数情况下<code>/n</code>后还要跟一个<code>/t</code>，其中<code>/n</code>是为了换行，<code>/t</code>是为了空出一个tab宽度的空格）将它们分开。比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__(<span style="color:#e6db74">&#34;movl %eax, %ebx sti popl %edi subl %ecx, %ebx&#34;</span>);
__asm__(<span style="color:#e6db74">&#34;movl %eax, %ebx; sti popl %edi; subl %ecx, %ebx&#34;</span>);
__asm__(<span style="color:#e6db74">&#34;movl %eax, %ebx; sti/n/t popl %edisubl %ecx, %ebx&#34;</span>);
</code></pre></div><p>都是合法的写法。如果你将指令放在多对引号中，则除了最后一对引号之外，前面的所有引号里的最后一条指令之后都要有一个分号(<code>;</code>)或(<code>/n</code>)或(<code>/n/t</code>)。比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__(<span style="color:#e6db74">&#34;movl %eax, %ebx sti/n&#34;</span> <span style="color:#e6db74">&#34;popl %edi;&#34;</span> <span style="color:#e6db74">&#34;subl %ecx, %ebx&#34;</span>);
__asm__(<span style="color:#e6db74">&#34;movl %eax, %ebx; sti/n/t&#34;</span> <span style="color:#e6db74">&#34;popl %edi; subl %ecx, %ebx&#34;</span>);
__asm__(<span style="color:#e6db74">&#34;movl %eax, %ebx; sti/n/t popl %edi/n&#34;&#34;subl %ecx, %ebx&#34;</span>);
__asm__(<span style="color:#e6db74">&#34;movl %eax, %ebx; sti/n/t popl %edi;&#34;</span> <span style="color:#e6db74">&#34;subl %ecx, %ebx&#34;</span>);
</code></pre></div><p>都是合法的。</p>
<p>上述原则可以归结为：</p>
<ul>
<li>任意两个指令间要么被分号(；)分开，要么被放在两行；</li>
<li>放在两行的方法既可以从通过/n的方法来实现，也可以真正的放在两行；</li>
<li>可以使用1对或多对引号，每1对引号里可以放任一多条指令，所有的指令都要被放到引号中。</li>
</ul>
<p>在基本内联汇编中，“Instruction List”的书写的格式和你直接在汇编文件中写非内联汇编没有什么不同，你可以在其中定义Label，定义对齐(.align n )，定义段(.section name )。例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__(<span style="color:#e6db74">&#34;.align 2/n/t&#34;</span>
        <span style="color:#e6db74">&#34;movl %eax, %ebx/n/t&#34;</span>
        <span style="color:#e6db74">&#34;test %ebx, %ecx/n/t&#34;</span>
        <span style="color:#e6db74">&#34;jne error/n/t&#34;</span>
        <span style="color:#e6db74">&#34;sti/n/t&#34;</span>
        <span style="color:#e6db74">&#34;error: popl %edi/n/t&#34;</span>
        <span style="color:#e6db74">&#34;subl %ecx, %ebx&#34;</span>);
</code></pre></div><p>上面例子的格式是Linux内联代码常用的格式，非常整齐。也建议大家都使用这种格式来写内联汇编代码。</p>
<h3 id="3__volatile__">3、<strong>volatile</strong></h3>
<p><code>__volatile__</code>是GCC关键字<code>volatile</code>的宏定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define __volatile__ volatile
</span></code></pre></div><p><code>__volatile__</code>或<code>volatile</code>是可选的，你可以用它也可以不用它。如果你用了它，则是向GCC声明“不要动我所写的Instruction List，我需要原封不动的保留每一条指令”，否则当你使用了优化选项(-O)进行编译时，GCC将会根据自己的判断决定是否将这个内联汇编表达式中的指令优化掉。</p>
<p>那么GCC判断的原则是什么？我不知道（如果有哪位朋友清楚的话，请告诉我）。我试验了一下，发现一条内联汇编语句如果是基本内联汇编的话（即只有“Instruction List”，没有Input/Output/Clobber的内联汇编，我们后面将会讨论这一点），无论你是否使用<code>__volatile__</code>来修饰， GCC 2.96在优化编译时，都会原封不动的保留内联汇编中的“Instruction List”。但或许我的试验的例子并不充分，所以这一点并不能够得到保证。</p>
<p>为了保险起见，如果你不想让GCC的优化影响你的内联汇编代码，你最好在前面都加上<code>__volatile__</code>，而不要依赖于编译器的原则，因为即使你非常了解当前编译器的优化原则，你也无法保证这种原则将来不会发生变化。而<code>__volatile__</code>的含义却是恒定的。</p>
<h2 id="3-带有cc表达式的内联汇编">3. 带有C/C++表达式的内联汇编</h2>
<p>GCC允许你通过C/C++表达式指定内联汇编中&quot;Instrcuction List&quot;中指令的输入和输出，你甚至可以不关心到底使用哪个寄存器被使用，完全靠GCC来安排和指定。这一点可以让程序员避免去考虑有限的寄存器的使用，也可以提高目标代码的效率。</p>
<p>我们先来看几个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__ (<span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;memory&#34;</span> ); 
<span style="color:#75715e">// 前面提到的
</span><span style="color:#75715e"></span>__asm__ (<span style="color:#e6db74">&#34;mov %%eax, %%ebx&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=b&#34;</span>(rv) <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;a&#34;</span>(foo) <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;eax&#34;</span>, <span style="color:#e6db74">&#34;ebx&#34;</span>);
__asm__ <span style="color:#a6e22e">__volatile__</span>(<span style="color:#e6db74">&#34;lidt %0&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=m&#34;</span> (idt_descr));
__asm__(<span style="color:#e6db74">&#34;subl %2,%0/n/t&#34;&#34;sbbl %3,%1&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=a&#34;</span> (endlow), <span style="color:#e6db74">&#34;=d&#34;</span> (endhigh)<span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;g&#34;</span> (startlow), <span style="color:#e6db74">&#34;g&#34;</span> (starthigh), <span style="color:#e6db74">&#34;0&#34;</span> (endlow), <span style="color:#e6db74">&#34;1&#34;</span> (endhigh));
</code></pre></div><p>怎么样，有点印象了吧，是不是也有点晕？没关系，下面讨论完之后你就不会再晕了。（当然，也有可能更晕^_^）。讨论开始——</p>
<p>带有C/C++表达式的内联汇编格式为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__　<span style="color:#a6e22e">__volatile__</span>(<span style="color:#e6db74">&#34;Instruction List&#34;</span> <span style="color:#f92672">:</span> Output : Input : Clobber<span style="color:#f92672">/</span>Modify);
</code></pre></div><p>从中我们可以看出它和基本内联汇编的不同之处在于：它多了3个部分(Input，Output，Clobber/Modify)。在括号中的4个部分通过冒号(:)分开。</p>
<p>这4个部分都不是必须的，任何一个部分都可以为空，其规则为：</p>
<ul>
<li>
<p>如果Clobber/Modify为空，则其前面的冒号(:)必须省略。比如<code>__asm__(&quot;mov %%eax, %%ebx&quot; : &quot;=b&quot;(foo) : &quot;a&quot;(inp) : )</code>就是非法的写法；而<code>__asm__(&quot;mov %%eax, %%ebx&quot; : &quot;=b&quot;(foo) : &quot;a&quot;(inp) )</code>则是正确的。</p>
</li>
<li>
<p>如果Instruction List为空，则Input，Output，Clobber/Modify可以不为空，也可以为空。比如<code>__asm__ ( &quot; &quot; : : : &quot;memory&quot; );</code>和<code>__asm__(&quot; &quot; : : );</code>都是合法的写法。</p>
</li>
<li>
<p>如果Output，Input，Clobber/Modify都为空，Output，Input之前的冒号(:)既可以省略，也可以不省略。</p>
</li>
<li>
<p>如果都省略，则此汇编退化为一个基本内联汇编，否则，仍然是一个带有C/C++表达式的内联汇编，此时&quot;Instruction List&quot;中的寄存器写法要遵守相关规定，比如寄存器前必须使用两个百分号(%%)，而不是像基本汇编格式一样在寄存器前只使用一个百分号(%)。比如 <code>__asm__( &quot; mov %%eax,  %%ebx&quot; : : )；__asm__( &quot; mov %%eax, %%ebx&quot; : )</code>和<code>__asm__( &quot; mov %eax, %ebx&quot; )</code>都是正确的写法，而<code>__asm__( &quot; mov %eax, %ebx&quot; : : )；__asm__( &quot; mov %eax, %ebx&quot; : )</code>和<code>__asm__( &quot; mov %%eax, %%ebx&quot; )</code>都是错误的写法。</p>
</li>
<li>
<p>如果Input，Clobber/Modify为空，但Output不为空，Input前的冒号(:)既可以省略，也可以不省略。比如 <code>__asm__( &quot; mov %%eax, %%ebx&quot; : &quot;=b&quot;(foo) : )；__asm__( &quot; mov %%eax, %%ebx&quot; : &quot;=b&quot;(foo) )</code>都是正确的。</p>
</li>
<li>
<p>如果后面的部分不为空，而前面的部分为空，则前面的冒号(:)都必须保留，否则无法说明不为空的部分究竟是第几部分。比如， Clobber/Modify，Output为空，而Input不为空，则Clobber/Modify前的冒号必须省略（前面的规则），而Output 前的冒号必须为保留。如果Clobber/Modify不为空，而Input和Output都为空，则Input和Output前的冒号都必须保留。比如<code>__asm__( &quot; mov %%eax, %%ebx&quot; : : &quot;a&quot;(foo) )</code>和<code>__asm__( &quot; mov %%eax, %%ebx&quot; : : : &quot;ebx&quot; )</code>。</p>
</li>
</ul>
<p>从上面的规则可以看到另外一个事实，区分一个内联汇编是基本格式的还是带有C/C++表达式格式的，其规则在于在&quot;Instruction List&quot;后是否有冒号(:)的存在，如果没有则是基本格式的，否则，则是带有C/C++表达式格式的。</p>
<p>两种格式对寄存器语法的要求不同：基本格式要求寄存器前只能使用一个百分号(%)，这一点和非内联汇编相同；而带有C/C++表达式格式则要求寄存器前必须使用两个百分号(%%)，其原因我们会在后面讨论。</p>
<h3 id="1-output">1. Output</h3>
<p>Output用来指定当前内联汇编语句的输出。我们看一看这个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__(<span style="color:#e6db74">&#34;movl %%cr0, %0&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=a&#34;</span> (cr0));
</code></pre></div><p>这个内联汇编语句的输出部分为<code>&quot;=r&quot;(cr0)</code>，它是一个“操作表达式”，指定了一个输出操作。我们可以很清楚得看到这个输出操作由两部分组成：括号括住的部分<code>(cr0)</code>和引号引住的部分<code>&quot;=a&quot;</code>。这两部分都是每一个输出操作必不可少的。括号括住的部分是一个C/C++表达式，用来保存内联汇编的一个输出值，其操作就等于C/C++的相等赋值<code>cr0 = output_value</code>，因此，括号中的输出表达式只能是C/C++的左值表达式，也就是说它只能是一个可以合法的放在C/C++赋值操作中等号(=)  左边的表达式。那么右值output_value从何而来呢？</p>
<p>答案是引号中的内容，被称作“操作约束”（Operation Constraint），在这个例子中操作约束为<code>&quot;=a&quot;</code>，它包含两个约束：等号(=)和字母a，其中等号(=)说明括号中左值表达式cr0是一个  Write-Only的，只能够被作为当前内联汇编的输入，而不能作为输入。而字母a是寄存器<code>EAX/AX/AL</code>的简写，说明cr0的值要从eax寄存器中获取，也就是说cr0 = eax，最终这一点被转化成汇编指令就是<code>movl %eax, address_of_cr0</code>。现在你应该清楚了吧，操作约束中会给出：到底从哪个寄存器传递值给cr0。</p>
<p>另外，需要特别说明的是，很多文档都声明，所有输出操作的操作约束必须包含一个等号(=)，但GCC的文档中却很清楚的声明，并非如此。因为等号(=)约束说明当前的表达式是一个 Write-Only的，但另外还有一个符号——加号(+)用来说明当前表达式是一个Read-Write的，如果一个操作约束中没有给出这两个符号中的任何一个，则说明当前表达式是Read-Only的。因为对于输出操作来说，肯定是必须是可写的，而等号(=)和加号(+)都表示可写，只不过加号(+)  同时也表示是可读的。所以对于一个输出操作来说，其操作约束只需要有等号(=)或加号(+)中的任意一个就可以了。</p>
<p>二者的区别是：等号(=)表示当前操作表达式指定了一个纯粹的输出操作，而加号(+)则表示当前操作表达式不仅仅只是一个输出操作还是一个输入操作。但无论是等号(=)约束还是加号(+)约束所约束的操作表达式都只能放在Output域中，而不能被用在Input域中。</p>
<p>另外，有些文档声明：尽管GCC文档中提供了加号(+)约束，但在实际的编译中通不过；我不知道老版本会怎么样，我在GCC  2.96中对加号(+)约束的使用非常正常。</p>
<p>我们通过一个例子看一下，在一个输出操作中使用等号(=)约束和加号(+)约束的不同。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#960050;background-color:#1e0010">$</span> cat example2.c

<span style="color:#66d9ef">int</span> main(<span style="color:#66d9ef">int</span> __argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> __argv[])
{
    <span style="color:#66d9ef">int</span> cr0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    __asm__ <span style="color:#a6e22e">__volatile__</span>(<span style="color:#e6db74">&#34;movl %%cr0, %0&#34;</span>
                         <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=a&#34;</span>(cr0));
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#960050;background-color:#1e0010">$</span> gcc <span style="color:#f92672">-</span>S example2.c
<span style="color:#960050;background-color:#1e0010">$</span> cat example2.s

main: 
    pushl <span style="color:#f92672">%</span>ebp 
    movl <span style="color:#f92672">%</span>esp, <span style="color:#f92672">%</span>ebp 
    subl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">4</span>, <span style="color:#f92672">%</span>esp 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">5</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>ebp) <span style="color:#960050;background-color:#1e0010">#</span> cr0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
    <span style="color:#75715e">#APP 
</span><span style="color:#75715e"></span>    movl <span style="color:#f92672">%</span>cr0, <span style="color:#f92672">%</span>eax 
    <span style="color:#960050;background-color:#1e0010">#</span>NO_APP 
    movl <span style="color:#f92672">%</span>eax, <span style="color:#f92672">%</span>eax 
    movl <span style="color:#f92672">%</span>eax, <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>ebp) <span style="color:#960050;background-color:#1e0010">#</span> cr0 <span style="color:#f92672">=</span> <span style="color:#f92672">%</span>eax
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">%</span>eax 
    leave 
    ret
</code></pre></div><p>这个例子是使用等号(=)约束的情况，变量cr0被放在内存-4(%ebp)的位置，所以指令<code>mov %eax, -4(%ebp)</code>即表示将%eax的内容输出到变量cr0中。</p>
<p>下面是使用加号(+)约束的情况：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#960050;background-color:#1e0010">$</span> cat example3.c

<span style="color:#66d9ef">int</span> main(<span style="color:#66d9ef">int</span> __argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> __argv[])
{
    <span style="color:#66d9ef">int</span> cr0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    __asm__ <span style="color:#a6e22e">__volatile__</span>(<span style="color:#e6db74">&#34;movl %%cr0, %0&#34;</span>
                         <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;+a&#34;</span>(cr0));
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#960050;background-color:#1e0010">$</span> gcc <span style="color:#f92672">-</span>S example3.c
<span style="color:#960050;background-color:#1e0010">$</span> cat example3.s

main: 
    pushl <span style="color:#f92672">%</span>ebp 
    movl <span style="color:#f92672">%</span>esp, <span style="color:#f92672">%</span>ebp 
    subl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">4</span>, <span style="color:#f92672">%</span>esp 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">5</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>ebp) <span style="color:#960050;background-color:#1e0010">#</span> cr0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
    movl <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>ebp), <span style="color:#f92672">%</span>eax <span style="color:#960050;background-color:#1e0010">#</span> input ( <span style="color:#f92672">%</span>eax <span style="color:#f92672">=</span> cr0 )
    <span style="color:#75715e">#APP 
</span><span style="color:#75715e"></span>    movl <span style="color:#f92672">%</span>cr0, <span style="color:#f92672">%</span>eax
    <span style="color:#75715e">#NO_APP
</span><span style="color:#75715e"></span>    movl <span style="color:#f92672">%</span>eax, <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>ebp) <span style="color:#960050;background-color:#1e0010">#</span> output (cr0 <span style="color:#f92672">=</span> <span style="color:#f92672">%</span>eax )
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">%</span>eax
    leave
    ret
</code></pre></div><p>从编译的结果可以看出，当使用加号(+)约束的时候，cr0不仅作为输出，还作为输入，所使用寄存器都是寄存器约束(字母a，表示使用eax寄存器)指定的。关于寄存器约束我们后面讨论。</p>
<p>在Output域中可以有多个输出操作表达式，多个操作表达式中间必须用逗号(,)分开。例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__( <span style="color:#e6db74">&#34;movl %%eax, %0 /n/t&#34;</span> <span style="color:#e6db74">&#34;pushl %%ebx /n/t&#34;</span> <span style="color:#e6db74">&#34;popl %1 /n/t&#34;</span> <span style="color:#e6db74">&#34;movl %1, %2&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;+a&#34;</span>(cr0), <span style="color:#e6db74">&#34;=b&#34;</span>(cr1), <span style="color:#e6db74">&#34;=c&#34;</span>(cr2));
</code></pre></div><h3 id="2-input">2. Input</h3>
<p>Input域的内容用来指定当前内联汇编语句的输入。我们看一看这个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__(<span style="color:#e6db74">&#34;movl %0, %%db7&#34;</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;a&#34;</span> (cpu<span style="color:#f92672">-&gt;</span>db7));
</code></pre></div><p>例中Input域的内容为一个表达式<code>&quot;a&quot;[cpu-&gt;db7)</code>，被称作“输入表达式”，用来表示一个对当前内联汇编的输入。</p>
<p>像输出表达式一样，一个输入表达式也分为两部分：带括号的部分<code>(cpu-&gt;db7)</code>和带引号的部分<code>&quot;a&quot;</code>。这两部分对于一个内联汇编输入表达式来说也是必不可少的。</p>
<p>括号中的表达式cpu-&gt;db7是一个C/C++语言的表达式，它不必是一个左值表达式，也就是说它不仅可以是放在C/C++赋值操作左边的表达式，还可以是放在C/C++赋值操作右边的表达式。所以它可以是一个变量，一个数字，还可以是一个复杂的表达式（比如a+b/c*d）。比如上例可以改为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__(<span style="color:#e6db74">&#34;movl %0, %%db7&#34;</span>
        <span style="color:#f92672">:</span>
        <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;a&#34;</span>(foo));
__asm__(<span style="color:#e6db74">&#34;movl %0, %%db7&#34;</span>
        <span style="color:#f92672">:</span>
        <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;a&#34;</span>(<span style="color:#ae81ff">0x1000</span>));
__asm__(<span style="color:#e6db74">&#34;movl %0, %%db7&#34;</span>
        <span style="color:#f92672">:</span>
        <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;a&#34;</span>(va <span style="color:#f92672">*</span> vb <span style="color:#f92672">/</span> vc));
</code></pre></div><p>引号号中的部分是约束部分，和输出表达式约束不同的是，它不允许指定加号(+)约束和等号(=)约束，也就是说它只能是默认的Read-Only的。约束中必须指定一个寄存器约束，例中的字母a表示当前输入变量cpu-&gt;db7要通过寄存器eax输入到当前内联汇编中。</p>
<p>我们看一个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#960050;background-color:#1e0010">$</span> cat example4.c

<span style="color:#66d9ef">int</span> main(<span style="color:#66d9ef">int</span> __argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> __argv[])
{
    <span style="color:#66d9ef">int</span> cr0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    __asm__ <span style="color:#a6e22e">__volatile__</span>(<span style="color:#e6db74">&#34;movl %0, %%cr0&#34;</span> <span style="color:#f92672">::</span><span style="color:#e6db74">&#34;a&#34;</span>(cr0));
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#960050;background-color:#1e0010">$</span> gcc <span style="color:#f92672">-</span>S example4.c
<span style="color:#960050;background-color:#1e0010">$</span> cat example4.s

main: 
    pushl <span style="color:#f92672">%</span>ebp 
    movl <span style="color:#f92672">%</span>esp, <span style="color:#f92672">%</span>ebp 
    subl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">4</span>, <span style="color:#f92672">%</span>esp 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">5</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>ebp) <span style="color:#960050;background-color:#1e0010">#</span> cr0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span> 
    movl <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>ebp), <span style="color:#f92672">%</span>eax <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#f92672">%</span>eax <span style="color:#f92672">=</span> cr0
    <span style="color:#75715e">#APP 
</span><span style="color:#75715e"></span>    movl <span style="color:#f92672">%</span>eax, <span style="color:#f92672">%</span>cr0 
    <span style="color:#960050;background-color:#1e0010">#</span>NO_APP 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">%</span>eax 
    leave 
    ret
</code></pre></div><p>我们从编译出的汇编代码可以看到，在&quot;Instruction List&quot;之前，GCC按照我们的输入约束&quot;a&rdquo;，将变量cr0的内容装入了eax寄存器。</p>
<h3 id="3-operation-constraint">3. Operation Constraint</h3>
<p>每一个Input和Output表达式都必须指定自己的操作约束Operation Constraint，我们这里来讨论在80386平台上所可能使用的操作约束。</p>
<h4 id="1寄存器约束">1、寄存器约束</h4>
<p>当你当前的输入或输入需要借助一个寄存器时，你需要为其指定一个寄存器约束。你可以直接指定一个寄存器的名字，比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__ <span style="color:#a6e22e">__volatile__</span>(<span style="color:#e6db74">&#34;movl %0, %%cr0&#34;</span><span style="color:#f92672">::</span><span style="color:#e6db74">&#34;eax&#34;</span> (cr0));
</code></pre></div><p>也可以指定一个缩写，比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__ <span style="color:#a6e22e">__volatile__</span>(<span style="color:#e6db74">&#34;movl %0, %%cr0&#34;</span><span style="color:#f92672">::</span><span style="color:#e6db74">&#34;a&#34;</span> (cr0));
</code></pre></div><p>如果你指定一个缩写，比如字母a，则GCC将会根据当前操作表达式中C/C++表达式的宽度决定使用%eax，还是%ax或%al。比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> __shrt;__asm__ (<span style="color:#e6db74">&#34;mov %0，%%bx&#34;</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;a&#34;</span>(__shrt));
</code></pre></div><p>由于变量__shrt是16-bit short类型，则编译出来的汇编代码中，则会让此变量使用%ax寄存器。编译结果为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">movw <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>(<span style="color:#f92672">%</span>ebp), <span style="color:#f92672">%</span>ax <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#f92672">%</span>ax <span style="color:#f92672">=</span> __shrt<span style="color:#960050;background-color:#1e0010">#</span>APPmovl <span style="color:#f92672">%</span>ax, <span style="color:#f92672">%</span>bx<span style="color:#960050;background-color:#1e0010">#</span>NO_APP
</code></pre></div><p>无论是Input，还是Output操作表达式约束，都可以使用寄存器约束。</p>
<p>下表中列出了常用的寄存器约束的缩写。</p>
<p>约束 Input/Output 意义</p>
<ul>
<li>r I,O 表示使用一个通用寄存器，由GCC在%eax/%ax/%al, %ebx/%bx/%bl, %ecx/%cx/%cl, %edx/%dx/%dl中选取一个GCC认为合适的。</li>
<li>q I,O 表示使用一个通用寄存器，和r的意义相同。</li>
<li>a I,O 表示使用%eax / %ax / %al</li>
<li>b I,O 表示使用%ebx / %bx / %bl</li>
<li>c I,O 表示使用%ecx / %cx / %cl</li>
<li>d I,O 表示使用%edx / %dx / %dl</li>
<li>D I,O 表示使用%edi / %di</li>
<li>S I,O 表示使用%esi / %si</li>
<li>f I,O 表示使用浮点寄存器</li>
<li>t I,O 表示使用第一个浮点寄存器</li>
<li>u I,O 表示使用第二个浮点寄存器</li>
</ul>
<h4 id="2内存约束">2、内存约束</h4>
<p>如果一个Input/Output操作表达式的C/C++表达式表现为一个内存地址，不想借助于任何寄存器，则可以使用内存约束。比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__ (<span style="color:#e6db74">&#34;lidt %0&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=m&#34;</span>(__idt_addr)); <span style="color:#75715e">//或者__asm__ (&#34;lidt %0&#34; : :&#34;m&#34;(__idt_addr));
</span></code></pre></div><p>我们看一下它们分别被放在一个C源文件中，然后被GCC编译后的结果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#960050;background-color:#1e0010">$</span> cat example5.c<span style="color:#75715e">// 本例中，变量sh被作为一个内存输入
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> main(<span style="color:#66d9ef">int</span> __argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> __argv[])
{
    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> sh <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__argc;
    __asm__ <span style="color:#a6e22e">__volatile__</span>(<span style="color:#e6db74">&#34;lidt %0&#34;</span>
                         <span style="color:#f92672">:</span>
                         <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;m&#34;</span>(sh));
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#960050;background-color:#1e0010">$</span> gcc <span style="color:#f92672">-</span>S example5.c
<span style="color:#960050;background-color:#1e0010">$</span> cat example5.s

main: 
    pushl <span style="color:#f92672">%</span>ebp 
    movl <span style="color:#f92672">%</span>esp, <span style="color:#f92672">%</span>ebp 
    subl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">4</span>, <span style="color:#f92672">%</span>esp 
    leal <span style="color:#ae81ff">8</span>(<span style="color:#f92672">%</span>ebp), <span style="color:#f92672">%</span>eax <span style="color:#75715e">//ebp的值+8 赋值给eax的是ebp中的值  &amp;__argc
</span><span style="color:#75715e"></span>    movl <span style="color:#f92672">%</span>eax, <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>ebp) <span style="color:#960050;background-color:#1e0010">#</span> sh <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>) <span style="color:#f92672">&amp;</span>__argc
    <span style="color:#75715e">#APP 
</span><span style="color:#75715e"></span>    lidt <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>ebp) 
    <span style="color:#960050;background-color:#1e0010">#</span>NO_APP 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">%</span>eax 
    leave 
    ret
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#960050;background-color:#1e0010">$</span> cat example6.c<span style="color:#75715e">// 本例中，变量sh被作为一个内存输出
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> main(<span style="color:#66d9ef">int</span> __argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> __argv[])
{
    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> sh <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__argc;
    __asm__ <span style="color:#a6e22e">__volatile__</span>(<span style="color:#e6db74">&#34;lidt %0&#34;</span>
                         <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=m&#34;</span>(sh));
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#960050;background-color:#1e0010">$</span> gcc <span style="color:#f92672">-</span>S example6.c
<span style="color:#960050;background-color:#1e0010">$</span> cat example6.s

main:
    pushl <span style="color:#f92672">%</span>ebp
    movl <span style="color:#f92672">%</span>esp, <span style="color:#f92672">%</span>ebp
    subl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">4</span>, <span style="color:#f92672">%</span>esp
    leal <span style="color:#ae81ff">8</span>(<span style="color:#f92672">%</span>ebp), <span style="color:#f92672">%</span>eax
    movl <span style="color:#f92672">%</span>eax, <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>ebp) <span style="color:#960050;background-color:#1e0010">#</span> sh <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>) <span style="color:#f92672">&amp;</span>__argc
    <span style="color:#75715e">#APP
</span><span style="color:#75715e"></span>    lidt <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>ebp)
    <span style="color:#75715e">#NO_APP
</span><span style="color:#75715e"></span>    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">%</span>eax
    leave
    ret
</code></pre></div><p>首先，你会注意到，在这两个例子中，变量sh没有借助任何寄存器，而是直接参与了指令<code>lidt</code>的操作。</p>
<p>其次，通过仔细观察，你会发现一个惊人的事实，两个例子编译出来的汇编代码是一样的！虽然，一个例子中变量sh作为输入，而另一个例子中变量sh作为输出。这是怎么回事？</p>
<p>原来，使用内存方式进行输入输出时，由于不借助寄存器，所以GCC不会按照你的声明对其作任何的输入输出处理。GCC只会直接拿来用，究竟对这个C/C++表达式而言是输入还是输出，完全依赖于你写在&quot;Instruction List&quot;中的指令对其操作的指令。</p>
<p>由于上例中，对其操作的指令为<code>lidt</code>，<code>lidt</code>指令的操作数是一个输入型的操作数，所以事实上对变量sh的操作是一个输入操作，即使你把它放在 Output域也不会改变这一点。所以，对此例而言，完全符合语意的写法应该是将sh放在Input域，尽管放在Output域也会有正确的执行结果。</p>
<p>所以，对于内存约束类型的操作表达式而言，放在Input域还是放在Output域，对编译结果是没有任何影响的，因为本来我们将一个操作表达式放在 Input域或放在Output域是希望GCC能为我们自动通过寄存器将表达式的值输入或输出。既然对于内存约束类型的操作表达式来说，GCC不会自动为它做任何事情，那么放在哪儿也就无所谓了。但从程序员的角度而言，为了增强代码的可读性，最好能够把它放在符合实际情况的地方。</p>
<p>约束 Input/Output 意义</p>
<p>m I,O 表示使用系统所支持的任何一种内存方式，不需要借助寄存器</p>
<h4 id="3立即数约束">3、立即数约束</h4>
<p>如果一个Input/Output操作表达式的C/C++表达式是一个数字常数，不想借助于任何寄存器，则可以使用立即数约束。</p>
<p>由于立即数在C/C++中只能作为右值，所以对于使用立即数约束的表达式而言，只能放在Input域。</p>
<p>比如：<strong>asm</strong> <strong>volatile</strong>(&ldquo;movl %0, %%eax&rdquo; : : &ldquo;i&rdquo; (100) );
立即数约束很简单，也很容易理解，我们在这里就不再赘述。</p>
<p>约束 Input/Output 意义</p>
<ul>
<li>i I 表示输入表达式是一个立即数(整数)，不需要借助任何寄存器</li>
<li>F I 表示输入表达式是一个立即数(浮点数)，不需要借助任何寄存器</li>
</ul>
<h4 id="4通用约束">4、通用约束</h4>
<p>约束 Input/Output 意义</p>
<ul>
<li>g I,O 表示可以使用通用寄存器，内存，立即数等任何一种处理方式。</li>
<li>0,1,2,3,4,5,6,7,8,9 I 表示和第n个操作表达式使用相同的寄存器/内存。</li>
</ul>
<p>通用约束g是一个非常灵活的约束，当程序员认为一个C/C++表达式在实际的操作中，究竟使用寄存器方式，还是使用内存方式或立即数方式并无所谓时，或者程序员想实现一个灵活的模板，让GCC可以根据不同的C/C++表达式生成不同的访问方式时，就可以使用通用约束g。比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define JUST_MOV(foo) __asm__ (&#34;movl %0, %%eax&#34; : : &#34;g&#34;(foo))
</span></code></pre></div><p>JUST_MOV(100)和JUST_MOV(var)则会让编译器产生不同的代码。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> __argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> __argv[])
{
    JUST_MOV(<span style="color:#ae81ff">100</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>编译后生成的代码为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">main: 
    pushl <span style="color:#f92672">%</span>ebp 
    movl <span style="color:#f92672">%</span>esp, <span style="color:#f92672">%</span>ebp 
    <span style="color:#960050;background-color:#1e0010">#</span>APP 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">100</span>, <span style="color:#f92672">%</span>eax 
    <span style="color:#960050;background-color:#1e0010">#</span>NO_APP 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">%</span>eax 
    popl <span style="color:#f92672">%</span>ebp 
    ret
</code></pre></div><p>很明显这是立即数方式。而下一个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> __argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> __argv[])
{
    JUST_MOV(__argc);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>经编译后生成的代码为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">main: 
    pushl <span style="color:#f92672">%</span>ebp 
    movl <span style="color:#f92672">%</span>esp, <span style="color:#f92672">%</span>ebp 
    <span style="color:#960050;background-color:#1e0010">#</span>APP 
    movl <span style="color:#ae81ff">8</span>(<span style="color:#f92672">%</span>ebp), <span style="color:#f92672">%</span>eax 
    <span style="color:#960050;background-color:#1e0010">#</span>NO_APP 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">%</span>eax 
    popl <span style="color:#f92672">%</span>ebp 
    ret
</code></pre></div><p>这个例子是使用内存方式。</p>
<p>一个带有C/C++表达式的内联汇编，其操作表达式被按照被列出的顺序编号，第一个是0，第2个是1，依次类推，GCC最多允许有10个操作表达式。比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__(<span style="color:#e6db74">&#34;popl %0 /n/t&#34;</span>
        <span style="color:#e6db74">&#34;movl %1, %%esi /n/t&#34;</span>
        <span style="color:#e6db74">&#34;movl %2, %%edi /n/t&#34;</span>
        <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=a&#34;</span>(__out)
        <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;r&#34;</span>(__in1), <span style="color:#e6db74">&#34;r&#34;</span>(__in2));
</code></pre></div><p>此例中，__out所在的Output操作表达式被编号为0，&ldquo;r&rdquo;(__in1)被编号为1，&ldquo;r&rdquo;(__in2)被编号为2。</p>
<p>再如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__(<span style="color:#e6db74">&#34;movl %%eax, %%ebx&#34;</span>
        <span style="color:#f92672">:</span>
        <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;a&#34;</span>(__in1), <span style="color:#e6db74">&#34;b&#34;</span>(__in2));
</code></pre></div><p>此例中，<code>&quot;a&quot;(__in1)</code>被编号为0，<code>&quot;b&quot;(__in2)</code>被编号为1。</p>
<p>如果某个Input操作表达式使用数字0到9中的一个数字（假设为1）作为它的操作约束，则等于向GCC声明：“我要使用和编号为1的Output操作表达式相同的寄存器（如果Output操作表达式1使用的是寄存器），或相同的内存地址（如果Output操作表达式1使用的是内存）”。上面的描述包含两个限定：数字0到数字9作为操作约束只能用在Input操作表达式中，被指定的操作表达式（比如某个Input操作表达式使用数字1作为约束，那么被指定的就是编号为1的操作表达式）只能是Output操作表达式。</p>
<p>由于GCC规定最多只能有10个Input/Output操作表达式，所以事实上数字9作为操作约束永远也用不到，因为Output操作表达式排在Input操作表达式的前面，那么如果有一个Input操作表达式指定了数字9作为操作约束的话，那么说明Output操作表达式的数量已经至少为10个了，那么再加上这个Input操作表达式，则至少为11个了，以及超出GCC的限制。</p>
<h4 id="5modifier-characters修饰符">5、Modifier Characters（修饰符）</h4>
<p>等号(=)和加号(+)用于对Output操作表达式的修饰，一个Output操作表达式要么被等号(=)修饰，要么被加号(+)修饰，二者必居其一。使用等号(=)说明此Output操作表达式是Write-Only的，使用加号(+)说明此Output操作表达式是Read-Write的。它们必须被放在约束字符串的第一个字母。比如<code>&quot;a=&quot;(foo)</code>是非法的，而<code>&quot;+g&quot;(foo)</code>则是合法的。</p>
<p>当使用加号(+)的时候，此Output表达式等价于使用等号(=)约束加上一个Input表达式。比如</p>
<p><code>__asm__ (&quot;movl %0, %%eax; addl %%eax, %0&quot; : &quot;+b&quot;(foo))</code>等价于<code>__asm__ (&quot;movl %1, %%eax; addl %%eax, %0&quot; : &quot;=b&quot;(foo) : &quot;b&quot;(foo))</code></p>
<p>但如果使用后一种写法，&ldquo;Instruction List&quot;中的别名也要相应的改动。关于别名，我们后面会讨论。</p>
<p>像等号(=)和加号(+)修饰符一样，符号(&amp;)也只能用于对Output操作表达式的修饰。当使用它进行修饰时，等于向GCC声明：&ldquo;GCC不得为任何Input操作表达式分配与此Output操作表达式相同的寄存器&rdquo;。其原因是&amp;修饰符意味着被其修饰的Output操作表达式要在所有的 Input操作表达式被输入前输出。我们看下面这个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> __argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> __argv[])
{
    <span style="color:#66d9ef">int</span> __in1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>, __in2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>, __out <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
    __asm__(<span style="color:#e6db74">&#34;popl %0 /n/t&#34;</span>
            <span style="color:#e6db74">&#34;movl %1, %%esi /n/t&#34;</span>
            <span style="color:#e6db74">&#34;movl %2, %%edi /n/t&#34;</span>
            <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=a&#34;</span>(__out)
            <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;r&#34;</span>(__in1), <span style="color:#e6db74">&#34;r&#34;</span>(__in2));
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>此例中，%0对应的就是Output操作表达式，它被指定的寄存器是%eax，整个Instruction List的第一条指令popl %0，编译后就成为popl %eax，这时%eax的内容已经被修改，随后在Instruction List后，GCC会通过<code>movl %eax, address_of_out</code>这条指令将%eax的内容放置到Output变量__out中。对于本例中的两个Input操作表达式而言，它们的寄存器约束为&quot;r&rdquo;，即要求GCC为其指定合适的寄存器，然后在Instruction  List之前将__in1和__in2的内容放入被选出的寄存器中，如果它们中的一个选择了已经被__out指定的寄存器%eax，假如是__in1，那么GCC在Instruction List之前会插入指令<code>movl address_of_in1, %eax</code>，那么随后<code>popl %eax</code>指令就修改了%eax的值，此时%eax中存放的已经不是Input变量__in1的值了，那么随后的<code>movl %1, %%esi</code>指令，将不会按照我们的本意——即将__in1的值放入%esi中——而是将__out的值放入%esi中了。</p>
<p>下面就是本例的编译结果，很明显，GCC为__in2选择了和__out相同的寄存器%eax，这与我们的初衷不符。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">main: 
    pushl <span style="color:#f92672">%</span>ebp 
    movl <span style="color:#f92672">%</span>esp, <span style="color:#f92672">%</span>ebp 
    subl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">12</span>, <span style="color:#f92672">%</span>esp 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">8</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>ebp) 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">4</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>(<span style="color:#f92672">%</span>ebp) 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">3</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">12</span>(<span style="color:#f92672">%</span>ebp) 
    movl <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>ebp), <span style="color:#f92672">%</span>edx <span style="color:#960050;background-color:#1e0010">#</span> __in1使用寄存器<span style="color:#f92672">%</span>edx
    movl <span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>(<span style="color:#f92672">%</span>ebp), <span style="color:#f92672">%</span>eax <span style="color:#960050;background-color:#1e0010">#</span> __in2使用寄存器<span style="color:#f92672">%</span>eax
    <span style="color:#75715e">#APP 
</span><span style="color:#75715e"></span>    popl <span style="color:#f92672">%</span>eax 
    movl <span style="color:#f92672">%</span>edx, <span style="color:#f92672">%</span>esi 
    movl <span style="color:#f92672">%</span>eax, <span style="color:#f92672">%</span>edi
    <span style="color:#75715e">#NO_APP 
</span><span style="color:#75715e"></span>    movl <span style="color:#f92672">%</span>eax, <span style="color:#f92672">%</span>eax 
    movl <span style="color:#f92672">%</span>eax, <span style="color:#f92672">-</span><span style="color:#ae81ff">12</span>(<span style="color:#f92672">%</span>ebp) <span style="color:#960050;background-color:#1e0010">#</span> __out使用寄存器<span style="color:#f92672">%</span>eax
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">%</span>eax 
    leave 
    ret
</code></pre></div><p>为了避免这种情况，我们必须向GCC声明这一点，要求GCC为所有的Input操作表达式指定别的寄存器，方法就是在Output操作表达式&quot;=a&rdquo; (__out)的操作约束中加入&amp;约束，由于GCC规定等号(=)约束必须放在第一个，所以我们写作&quot;=&amp;a&rdquo;(__out)。</p>
<p>下面是我们将&amp;约束加入之后编译的结果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">main: 
    pushl <span style="color:#f92672">%</span>ebp 
    movl <span style="color:#f92672">%</span>esp, <span style="color:#f92672">%</span>ebp 
    subl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">12</span>, <span style="color:#f92672">%</span>esp 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">8</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>ebp) 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">4</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>(<span style="color:#f92672">%</span>ebp) 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">3</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">12</span>(<span style="color:#f92672">%</span>ebp) 
    movl <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>ebp), <span style="color:#f92672">%</span>edx <span style="color:#960050;background-color:#1e0010">#</span>__in1使用寄存器<span style="color:#f92672">%</span>edx
    movl <span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>(<span style="color:#f92672">%</span>ebp), <span style="color:#f92672">%</span>eax 
    movl <span style="color:#f92672">%</span>eax, <span style="color:#f92672">%</span>ecx <span style="color:#960050;background-color:#1e0010">#</span> __in2使用寄存器<span style="color:#f92672">%</span>ecx
    <span style="color:#75715e">#APP 
</span><span style="color:#75715e"></span>    popl <span style="color:#f92672">%</span>eax 
    movl <span style="color:#f92672">%</span>edx, <span style="color:#f92672">%</span>esi 
    movl <span style="color:#f92672">%</span>ecx, <span style="color:#f92672">%</span>edi
    <span style="color:#75715e">#NO_APP 
</span><span style="color:#75715e"></span>    movl <span style="color:#f92672">%</span>eax, <span style="color:#f92672">%</span>eax 
    movl <span style="color:#f92672">%</span>eax, <span style="color:#f92672">-</span><span style="color:#ae81ff">12</span>(<span style="color:#f92672">%</span>ebp) <span style="color:#960050;background-color:#1e0010">#</span>__out使用寄存器<span style="color:#f92672">%</span>eax
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">%</span>eax 
    leave 
    ret
</code></pre></div><p>OK！这下好了，完全与我们的意图吻合。</p>
<p>如果一个Output操作表达式的寄存器约束被指定为某个寄存器，只有当至少存在一个Input操作表达式的寄存器约束为可选约束时，（可选约束的意思是可以从多个寄存器中选取一个，或使用非寄存器方式），比如&quot;r&quot;或&quot;g&quot;时，此Output操作表达式使用&amp;修饰才有意义。如果你为所有的 Input操作表达式指定了固定的寄存器，或使用内存/立即数约束，则此Output操作表达式使用&amp;修饰没有任何意义。比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__ (<span style="color:#e6db74">&#34;popl %0 /n/t&#34;</span> <span style="color:#e6db74">&#34;movl %1, %%esi /n/t&#34;</span> <span style="color:#e6db74">&#34;movl %2, %%edi /n/t&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=&amp;a&#34;</span>(__out) <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;m&#34;</span> (__in1), <span style="color:#e6db74">&#34;c&#34;</span> (__in2));
</code></pre></div><p>此例中的Output操作表达式完全没有必要使用&amp;来修饰，因为__in1和__in2都被指定了固定的寄存器，或使用了内存方式，GCC无从选择。</p>
<p>但如果你已经为某个Output操作表达式指定了&amp;修饰，并指定了某个固定的寄存器，你就不能再为任何Input操作表达式指定这个寄存器，否则会出现编译错误。比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__ (<span style="color:#e6db74">&#34;popl %0 /n/t&#34;</span> <span style="color:#e6db74">&#34;movl %1, %%esi /n/t&#34;</span> <span style="color:#e6db74">&#34;movl %2, %%edi /n/t&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=&amp;a&#34;</span>(__out) <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;a&#34;</span> (__in1), <span style="color:#e6db74">&#34;c&#34;</span> (__in2));
</code></pre></div><p>本例中，由于__out已经指定了寄存器%eax，同时使用了符号&amp;修饰，则再为__in1指定寄存器%eax就是非法的。</p>
<p>反过来，你也可以为Output指定可选约束，比如&quot;r&rdquo;,&ldquo;g&quot;等，让GCC为其选择到底使用哪个寄存器，还是使用内存方式，GCC在选择的时候，会首先排除掉已经被Input操作表达式使用的所有寄存器，然后在剩下的寄存器中选择，或干脆使用内存方式。比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__ (<span style="color:#e6db74">&#34;popl %0 /n/t&#34;</span> <span style="color:#e6db74">&#34;movl %1, %%esi /n/t&#34;</span> <span style="color:#e6db74">&#34;movl %2, %%edi /n/t&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=&amp;r&#34;</span>(__out) <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;a&#34;</span> (__in1), <span style="color:#e6db74">&#34;c&#34;</span> (__in2));
</code></pre></div><p>本例中，由于__out指定了约束&quot;r&rdquo;，即让GCC为其决定使用哪一个寄存器，而寄存器%eax和%ecx已经被__in1和__in2使用，那么GCC在为__out选择的时候，只会在%ebx和%edx中选择。</p>
<p>前3 个修饰符只能用在Output操作表达式中，而百分号[%]修饰符恰恰相反，只能用在Input操作表达式中，用于向GCC声明：“当前Input操作表达式中的C/C++表达式可以和下一个Input操作表达式中的C/C++表达式互换”。这个修饰符号一般用于符合交换律运算，比如加(+)，乘(*)，与(&amp;)，或(|)等等。我们看一个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> __argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> __argv[])
{
    <span style="color:#66d9ef">int</span> __in1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>, __in2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>, __out <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
    __asm__(<span style="color:#e6db74">&#34;addl %1, %0/n/t&#34;</span>
            <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=r&#34;</span>(__out)
            <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;%r&#34;</span>(__in1), <span style="color:#e6db74">&#34;0&#34;</span>(__in2));
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>在此例中，由于指令是一个加法运算，相当于等式<code>__out = __in1 + __in2</code>，而它与等式<code>__out = __in2 + __in1</code>没有什么不同。所以使用百分号修饰，让GCC知道__in1和__in2可以互换，也就是说GCC可以自动将本例的内联汇编改变为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__ (<span style="color:#e6db74">&#34;addl %1, %0/n/t&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=r&#34;</span>(__out)<span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;%r&#34;</span> (__in2), <span style="color:#e6db74">&#34;0&#34;</span> (__in1));
</code></pre></div><p>修饰符 Input/Output 意义</p>
<ul>
<li>= O 表示此Output操作表达式是Write-Only的</li>
<li>+ O 表示此Output操作表达式是Read-Write的</li>
<li>&amp; O 表示此Output操作表达式独占为其指定的寄存器</li>
<li>% I 表示此Input操作表达式中的C/C++表达式可以和下一个Input操作表达式中的C/C++表达式互换</li>
</ul>
<h3 id="4-占位符">4. 占位符</h3>
<p>什么叫占位符？我们看一看下面这个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__ (<span style="color:#e6db74">&#34;addl %1, %0/n/t&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=a&#34;</span>(__out)<span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;m&#34;</span> (__in1), <span style="color:#e6db74">&#34;a&#34;</span> (__in2));
</code></pre></div><p>这个例子中的%0和%1就是占位符。每一个占位符对应一个Input/Output操作表达式。我们在之前已经提到，GCC规定一个内联汇编语句最多可以有 10个Input/Output操作表达式，然后按照它们被列出的顺序依次赋予编号0到9。对于占位符中的数字而言，和这些编号是对应的。</p>
<p>由于占位符前面使用一个百分号(%)，为了区别占位符和寄存器，GCC规定在带有C/C++表达式的内联汇编中，&ldquo;Instruction List&quot;中直接写出的寄存器前必须使用两个百分号(%%)。</p>
<p>GCC 对其进行编译的时候，会将每一个占位符替换为对应的Input/Output操作表达式所指定的寄存器/内存地址/立即数。比如在上例中，占位符%0对应  Output操作表达式<code>&quot;=a&quot;(__out)</code>，而<code>&quot;=a&quot;(__out)</code>指定的寄存器为%eax，所以把占位符%0替换为%eax，占位符%1对应 Input操作表达式<code>&quot;m&quot;(__in1)</code>，而<code>&quot;m&quot;(__in1)</code>被指定为内存操作，所以把占位符%1替换为变量__in1的内存地址。</p>
<p>也许有人认为，在上面这个例子中，完全可以不使用%0，而是直接写%%eax，就像这样：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__ (<span style="color:#e6db74">&#34;addl %1, %%eax/n/t&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=a&#34;</span>(__out)<span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;m&#34;</span> (__in1), <span style="color:#e6db74">&#34;a&#34;</span> (__in2));
</code></pre></div><p>和上面使用占位符%0没有什么不同，那么使用占位符%0就没有什么意义。确实，两者生成的代码完全相同，但这并不意味着这种情况下占位符没有意义。因为如果不使用占位符，那么当有一天你想把变量__out的寄存器约束由a改为b时，那么你也必须将addl指令中的%%eax改为%%ebx，也就是说你需要同时修改两个地方，而如果你使用占位符，你只需要修改一次就够了。另外，如果你不使用占位符，将不利于代码的清晰性。在上例中，如果你使用占位符，那么你一眼就可以得知，addl指令的第二个操作数内容最终会输出到变量__out中；否则，如果你不用占位符，而是直接将addl指令的第2个操作数写为%%  eax，那么你需要考虑一下才知道它最终需要输出到变量__out中。这是占位符最粗浅的意义。毕竟在这种情况下，你完全可以不用。</p>
<p>但对于这些情况来说，不用占位符就完全不行了：</p>
<p>首先，我们看一看上例中的第1个Input操作表达式&quot;m&rdquo;(__in1)，它被GCC替换之后，表现为<code>addl  address_of_in1, %%eax</code>，__in1的地址是什么？编译时才知道。所以我们完全无法直接在指令中去写出__in1的地址，这时使用占位符，交给GCC在编译时进行替代，就可以解决这个问题。所以这种情况下，我们必须使用占位符。</p>
<p>其次，如果上例中的Output操作表达式&quot;=a&rdquo;(__out)改为&rdquo; =r&rdquo;(__out)，那么__out在究竟使用那么寄存器只有到编译时才能通过GCC来决定，既然在我们写代码的时候，我们不知道究竟哪个寄存器被选择，我们也就不能直接在指令中写出寄存器的名称，而只能通过占位符替代来解决。</p>
<h3 id="5-clobbermodify">5. Clobber/Modify</h3>
<p>有时候，你想通知GCC当前内联汇编语句可能会对某些寄存器或内存进行修改，希望GCC在编译时能够将这一点考虑进去。那么你就可以在Clobber/Modify域声明这些寄存器或内存。</p>
<p>这种情况一般发生在一个寄存器出现在&quot;Instruction List&rdquo;，但却不是由Input/Output操作表达式所指定的，也不是在一些Input/Output操作表达式使用&quot;r&rdquo;,&ldquo;g&quot;约束时由GCC  为其选择的，同时此寄存器被&quot;Instruction List&quot;中的指令修改，而这个寄存器只是供当前内联汇编临时使用的情况。比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__ (<span style="color:#e6db74">&#34;movl %0, %%ebx&#34;</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;a&#34;</span>(__foo) <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;bx&#34;</span>);
</code></pre></div><p>寄存器%ebx出现在&quot;Instruction List中&rdquo;，并且被movl指令修改，但却未被任何Input/Output操作表达式指定，所以你需要在Clobber/Modify域指定&quot;bx&rdquo;，以让GCC知道这一点。</p>
<p>因为你在Input/Output操作表达式所指定的寄存器，或当你为一些Input/Output操作表达式使用&quot;r&rdquo;,&ldquo;g&quot;约束，让GCC为你选择一个寄存器时，GCC对这些寄存器是非常清楚的——它知道这些寄存器是被修改的，你根本不需要在Clobber/Modify域再声明它们。但除此之外，  GCC对剩下的寄存器中哪些会被当前的内联汇编修改一无所知。所以如果你真的在当前内联汇编指令中修改了它们，那么就最好在Clobber/Modify 中声明它们，让GCC针对这些寄存器做相应的处理。否则有可能会造成寄存器的不一致，从而造成程序执行错误。</p>
<p>在Clobber/Modify域中指定这些寄存器的方法很简单，你只需要将寄存器的名字使用双引号(&rdquo; &ldquo;)引起来。如果有多个寄存器需要声明，你需要在任意两个声明之间用逗号隔开。比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__ (<span style="color:#e6db74">&#34;movl %0, %%ebx; popl %%ecx&#34;</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;a&#34;</span>(__foo) <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;bx&#34;</span>, <span style="color:#e6db74">&#34;cx&#34;</span> );
</code></pre></div><p>这些串包括：</p>
<p>声明的串 代表的寄存器</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#e6db74">&#34;al&#34;</span>,<span style="color:#e6db74">&#34;ax&#34;</span>,<span style="color:#e6db74">&#34;eax&#34;</span> <span style="color:#f92672">%</span>eax
<span style="color:#e6db74">&#34;bl&#34;</span>,<span style="color:#e6db74">&#34;bx&#34;</span>,<span style="color:#e6db74">&#34;ebx&#34;</span> <span style="color:#f92672">%</span>ebx
<span style="color:#e6db74">&#34;cl&#34;</span>,<span style="color:#e6db74">&#34;cx&#34;</span>,<span style="color:#e6db74">&#34;ecx&#34;</span> <span style="color:#f92672">%</span>ecx
<span style="color:#e6db74">&#34;dl&#34;</span>,<span style="color:#e6db74">&#34;dx&#34;</span>,<span style="color:#e6db74">&#34;edx&#34;</span> <span style="color:#f92672">%</span>edx
<span style="color:#e6db74">&#34;si&#34;</span>,<span style="color:#e6db74">&#34;esi&#34;</span> <span style="color:#f92672">%</span>esi
<span style="color:#e6db74">&#34;di&#34;</span>, <span style="color:#e6db74">&#34;edi&#34;</span> <span style="color:#f92672">%</span>edi
</code></pre></div><p>由上表可以看出，你只需要使用&quot;ax&rdquo;,&ldquo;bx&rdquo;,&ldquo;cx&rdquo;,&ldquo;dx&rdquo;,&ldquo;si&rdquo;,&ldquo;di&quot;就可以了，因为其它的都和它们中的一个是等价的。</p>
<p>如果你在一个内联汇编语句的Clobber/Modify域向GCC声明某个寄存器内容发生了改变，GCC在编译时，如果发现这个被声明的寄存器的内容在此内联汇编语句之后还要继续使用，那么GCC会首先将此寄存器的内容保存起来，然后在此内联汇编语句的相关生成代码之后，再将其内容恢复。我们来看两个例子，然后对比一下它们之间的区别。</p>
<p>这个例子中声明了寄存器%ebx内容发生了改变：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#960050;background-color:#1e0010">$</span> cat example7.c

<span style="color:#66d9ef">int</span> main(<span style="color:#66d9ef">int</span> __argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> __argv[])
{
    <span style="color:#66d9ef">int</span> in <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;
    __asm__(<span style="color:#e6db74">&#34;addl %0, %%ebx&#34;</span>
            <span style="color:#f92672">:</span> <span style="color:#75715e">/* no output */</span>
            <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;a&#34;</span>(in)
            <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;bx&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#960050;background-color:#1e0010">$</span> gcc <span style="color:#f92672">-</span>O <span style="color:#f92672">-</span>S example7.c
<span style="color:#960050;background-color:#1e0010">$</span> cat example7.s

main:
    pushl <span style="color:#f92672">%</span>ebp
    movl <span style="color:#f92672">%</span>esp, <span style="color:#f92672">%</span>ebp
    pushl <span style="color:#f92672">%</span>ebx <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#f92672">%</span>ebx内容被保存 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">8</span>, <span style="color:#f92672">%</span>eax
    <span style="color:#75715e">#APP
</span><span style="color:#75715e"></span>    addl <span style="color:#f92672">%</span>eax, <span style="color:#f92672">%</span>ebx
    <span style="color:#75715e">#NO_APP
</span><span style="color:#75715e"></span>    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">%</span>eax
    movl (<span style="color:#f92672">%</span>esp), <span style="color:#f92672">%</span>ebx <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#f92672">%</span>ebx内容被恢复  <span style="color:#75715e">//这里为什么不直接pop呢？
</span><span style="color:#75715e"></span>    leave
    ret
</code></pre></div><p>下面这个例子的C源码与上一个例子除了没有声明%ebx寄存器发生了改变之外，其它都相同。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#960050;background-color:#1e0010">$</span> cat example8.c

<span style="color:#66d9ef">int</span> main(<span style="color:#66d9ef">int</span> __argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> __argv[])
{
    <span style="color:#66d9ef">int</span> in <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;
    __asm__(<span style="color:#e6db74">&#34;addl %0, %%ebx&#34;</span>
            <span style="color:#f92672">:</span> <span style="color:#75715e">/* no output */</span>
            <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;a&#34;</span>(in));
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#960050;background-color:#1e0010">$</span> gcc <span style="color:#f92672">-</span>O <span style="color:#f92672">-</span>S example8.c
<span style="color:#960050;background-color:#1e0010">$</span> cat example8.s

main: 
    pushl <span style="color:#f92672">%</span>ebp 
    movl <span style="color:#f92672">%</span>esp, <span style="color:#f92672">%</span>ebp 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">8</span>, <span style="color:#f92672">%</span>eax 
    <span style="color:#960050;background-color:#1e0010">#</span>APP 
    addl <span style="color:#f92672">%</span>eax, <span style="color:#f92672">%</span>ebx 
    <span style="color:#960050;background-color:#1e0010">#</span>NO_APP 
    movl <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">%</span>eax 
    popl <span style="color:#f92672">%</span>ebp 
    ret
</code></pre></div><p>仔细对比一下example7.s和example8.s，你就会明白在Clobber/Modify域声明一个寄存器的意义。</p>
<p>另外需要注意的是，如果你在Clobber/Modify域声明了一个寄存器，那么这个寄存器将不能再被用做当前内联汇编语句的Input/Output操作表达式的寄存器约束，如果Input/Output操作表达式的寄存器约束被指定为&quot;r&quot;或&quot;g&rdquo;，GCC也不会选择已经被声明在 Clobber/Modify中的寄存器。比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__asm__ (<span style="color:#e6db74">&#34;movl %0, %%ebx&#34;</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;a&#34;</span>(__foo) <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;ax&#34;</span>, <span style="color:#e6db74">&#34;bx&#34;</span>);
</code></pre></div><p>此例中，由于Output操作表达式&quot;a&rdquo;(__foo)的寄存器约束已经指定了%eax寄存器，那么再在Clobber/Modify域中指定&quot;ax&quot;就是非法的。编译时，GCC会给出编译错误。</p>
<p>除了寄存器的内容会被改变，内存的内容也可以被修改。如果一个内联汇编语句&quot;Instruction List&quot;中的指令对内存进行了修改，或者在此内联汇编出现的地方内存内容可能发生改变，而被改变的内存地址你没有在其Output操作表达式使用&quot;m&rdquo; 约束，这种情况下你需要使用在Clobber/Modify域使用字符串&quot;memory&quot;向GCC声明：“在这里，内存发生了，或可能发生了改变”。例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">memset</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> s, <span style="color:#66d9ef">char</span> c, size_t count)
{
    __asm__(<span style="color:#e6db74">&#34;cld/n/t&#34;</span>
            <span style="color:#e6db74">&#34;rep/n/t&#34;</span>
            <span style="color:#e6db74">&#34;stosb&#34;</span>
            <span style="color:#f92672">:</span> <span style="color:#75715e">/* no output */</span>
            <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;a&#34;</span>(c), <span style="color:#e6db74">&#34;D&#34;</span>(s), <span style="color:#e6db74">&#34;c&#34;</span>(count)
            <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;cx&#34;</span>, <span style="color:#e6db74">&#34;di&#34;</span>, <span style="color:#e6db74">&#34;memory&#34;</span>);
    <span style="color:#66d9ef">return</span> s;
}
</code></pre></div><p>此例实现了标准函数库memset，其内联汇编中的stosb对内存进行了改动，而其被修改的内存地址s被指定装入%edi，没有任何Output操作表达式使用了&quot;m&quot;约束，以指定内存地址s处的内容发生了改变。所以在其Clobber/Modify域使用&quot;memory&quot;向GCC声明：内存内容发生了变动。</p>
<p>如果一个内联汇编语句的Clobber/Modify域存在&quot;memory&rdquo;，那么GCC会保证在此内联汇编之前，如果某个内存的内容被装入了寄存器，那么在这个内联汇编之后，如果需要使用这个内存处的内容，就会直接到这个内存处重新读取，而不是使用被存放在寄存器中的拷贝。因为这个时候寄存器中的拷贝已经很可能和内存处的内容不一致了。</p>
<p>这只是使用&quot;memory&quot;时，GCC会保证做到的一点，但这并不是全部。因为使用&quot;memory&quot;是向GCC声明内存发生了变化，而内存发生变化带来的影响并不止这一点。比如我们在前面讲到的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> __argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> __argv[])
{
    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> __p <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>)__argc;
    (<span style="color:#f92672">*</span>__p) <span style="color:#f92672">=</span> <span style="color:#ae81ff">9999</span>;
    __asm__(<span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">::</span>
                <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;memory&#34;</span>);
    <span style="color:#66d9ef">if</span> ((<span style="color:#f92672">*</span>__p) <span style="color:#f92672">==</span> <span style="color:#ae81ff">9999</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">5</span>;
    <span style="color:#66d9ef">return</span> (<span style="color:#f92672">*</span>__p);
}
</code></pre></div><p>本例中，如果没有那条内联汇编语句，那个if语句的判断条件就完全是一句废话。GCC在优化时会意识到这一点，而直接只生成return 5的汇编代码，而不会再生成if语句的相关代码，而不会生成<code>return (*__p)</code>的相关代码。但你加上了这条内联汇编语句，它除了声明内存变化之外，什么都没有做。但GCC此时就不能简单的认为它不需要判断都知道 <code>(*__p)</code>一定与9999相等，它只有老老实实生成这条if语句的汇编代码，一起相关的两个return语句相关代码。</p>
<p>当一个内联汇编指令中包含影响eflags寄存器中的条件标志（也就是那些Jxx等跳转指令要参考的标志位，比如，进位标志，0标志等），那么需要在  Clobber/Modify域中使用&quot;cc&quot;来声明这一点。这些指令包括<code>adc, div, popfl, btr，bts</code>等等，另外，当包含call指令时，由于你不知道你所call的函数是否会修改条件标志，为了稳妥起见，最好也使用 &ldquo;cc&rdquo;。</p>
<p>我很少在相关资料中看到有关&quot;cc&quot;的确切用法，只有一份文档提到了它，但还不是i386平台的，只是说&quot;cc&quot;是处理器平台相关的，并非所有的平台都支持它，但即使在不支持它的平台上，使用它也不会造成编译错误。我做了一些实验，但发现使用&quot;cc&quot;和不使用&quot;cc&quot;所生成的代码没有任何不同。但Linux  2.4的相关代码中用到了它。如果谁知道在i386平台上&quot;cc&quot;的细节，请和我联系。</p>
<p>另外，还可以在 Clobber/Modify域指定数字0到9，以声明第n个Input/Output操作表达式所使用的寄存器发生了变化，但正如我们在前面所提到的，如果你为某个Input/Output操作表达式指定了寄存器，或使用<code>&quot;g&quot;,&quot;r&quot;</code>等约束让GCC为其选择寄存器，GCC已经知道哪个寄存器内容发生了变化，所以这么做没有什么意义；我也做了相关的试验，没有发现使用它会对GCC生成的汇编代码有任何影响，至少在i386平台上是这样。</p>
<p>Linux  2.4的所有i386平台相关内联汇编代码中都没有使用这一点，但S390平台相关代码中有用到，但由于我对S390汇编没有任何概念，所以，也不知道这么做的意义何在。</p>

        </div>

        


        


        <div class="post-meta meta-tags">
            
            没有标签
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2022 <a href="https://axiomaster.gitee.io/">Axiomaster&#39;s Site By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>






                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='//www.google.com/search' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://axiomaster.gitee.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2022-01-01-c-language/" title="引入c语言">引入c语言</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-12-26-protected_mode-addition/" title="保护模式补充">保护模式补充</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-12-19-page/" title="内存分页">内存分页</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-12-18-protected_mode/" title="保护模式">保护模式</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-12-04-os-loader-addition/" title="确认软盘内容执行">确认软盘内容执行</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-11-22-os-loader/" title="读取并执行软盘内容">读取并执行软盘内容</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-11-21-os-boot-addition/" title="启动补充说明">启动补充说明</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-11-17-os-boot/" title="从上电到引导扇区">从上电到引导扇区</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-10-31-gcc-inline-asm/" title="GCC Inline ASM">GCC Inline ASM</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2020-09-03-tensorflow2_2/" title="Tensorflow2.0 笔记（2）">Tensorflow2.0 笔记（2）</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="https://axiomaster.gitee.io/tags/activity/">activity</a>
    
    <a href="https://axiomaster.gitee.io/tags/algorithm/">algorithm</a>
    
    <a href="https://axiomaster.gitee.io/tags/android/">android</a>
    
    <a href="https://axiomaster.gitee.io/tags/aosp/">aosp</a>
    
    <a href="https://axiomaster.gitee.io/tags/bazel/">bazel</a>
    
    <a href="https://axiomaster.gitee.io/tags/bug/">bug</a>
    
    <a href="https://axiomaster.gitee.io/tags/debug/">debug</a>
    
    <a href="https://axiomaster.gitee.io/tags/debugger/">debugger</a>
    
    <a href="https://axiomaster.gitee.io/tags/docker/">docker</a>
    
    <a href="https://axiomaster.gitee.io/tags/golang/">golang</a>
    
    <a href="https://axiomaster.gitee.io/tags/gradle/">Gradle</a>
    
    <a href="https://axiomaster.gitee.io/tags/i/o/">I/O</a>
    
    <a href="https://axiomaster.gitee.io/tags/idea%E6%8F%92%E4%BB%B6/">IDEA插件</a>
    
    <a href="https://axiomaster.gitee.io/tags/java/">java</a>
    
    <a href="https://axiomaster.gitee.io/tags/linux/">linux</a>
    
    <a href="https://axiomaster.gitee.io/tags/ml/">ML</a>
    
    <a href="https://axiomaster.gitee.io/tags/net/">net</a>
    
    <a href="https://axiomaster.gitee.io/tags/nginx/">nginx</a>
    
    <a href="https://axiomaster.gitee.io/tags/os/">OS</a>
    
    <a href="https://axiomaster.gitee.io/tags/tensorflow/">Tensorflow</a>
    
    <a href="https://axiomaster.gitee.io/tags/tool/">tool</a>
    
    <a href="https://axiomaster.gitee.io/tags/view/">view</a>
    
    <a href="https://axiomaster.gitee.io/tags/window/">window</a>
    
    <a href="https://axiomaster.gitee.io/tags/zookeeper/">zookeeper</a>
    
    <a href="https://axiomaster.gitee.io/tags/zygote/">zygote</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E5%86%85%E5%AD%98/">内存</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E5%90%90%E6%A7%BD/">吐槽</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E5%B7%A5%E5%85%B7/">工具</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E5%B9%B6%E5%8F%91/">并发</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E6%89%8B%E5%B7%A5/">手工</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E6%89%AF%E6%B7%A1/">扯淡</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E6%97%A5%E5%B8%B8/">日常</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E7%94%9F%E6%B4%BB/">生活</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E7%A5%9E%E5%A5%87%E7%9A%84bug/">神奇的bug</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E8%AF%81%E4%B9%A6/">证书</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E9%93%BE%E6%8E%A5/">链接</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://axiomaster.gitee.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>
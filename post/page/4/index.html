<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    

    <title>Posts | Axiomaster&#39;s Site</title>
    <meta property="og:title" content="Posts - Axiomaster&#39;s Site">
    <meta property="og:type" content="article">
        
        
    <meta name="Keywords" content="">
    <meta name="description" content="Posts">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://axiomaster.gitee.io/post/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <link rel="alternate" type="application/rss+xml" href="https://axiomaster.gitee.io/post/index.xml" title="Axiomaster's Site" />
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://axiomaster.gitee.io/">
                        Axiomaster&#39;s Site
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://axiomaster.gitee.io/">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://axiomaster.gitee.io/post/2019-04-27-java-concurrent/" title="Java并发编程">Java并发编程</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2019年4月27日
        </date>
        
        <div class="post-content">
            缓存一致性与并发问题 我们今天使用的计算机体系结构都属于存储程序型（冯·诺伊曼结构），运行时所有的数据都存储在内存中；指令执行时，数据从内存读入寄存器，运算结束后再写回内存。
// i == 0 i = i + 1 // i == 1 以上面代码为例，计算机先将i加载到寄存器中，再寄存器中+1后再将i写回内存。
可以认为运算中，寄存器中的数据是内存的一份缓存。但是，有缓存，就有缓存不一致的问题。
我们只考虑多CPU时的并发问题。单线程执行时，以上执行顺序不存在问题；但并发场景下，假设2个线程A、B同时执行，A读入寄存器的值均为0, 计算后都为1，在A写入内存前，B此时读取到的值为0，最终写入内存的i为1，显然存在问题。
解决缓存不一致问题，通常有2种方法：
 在总线加锁； 使用缓存一致性协议；  总线加锁 CPU通过总线读取内存，通过在总线加锁，锁未释放前，CPU只能再次读取i所在内存，直到锁释放。早期CPU采用这种方式，这样可以解决不一致问题，但这等于同一块内存锁释放前无法访问。
缓存一致性协议 Intel的MESI协议，提供了如下机制：CPU写数据时，如果发现变量是共享变量，会发信号通知其它CPU将该变量的缓存置为无效状态。其它CPU操作时发现缓存失效了，就会重新从内存读取。
并发编程中的概念 原子性 提到原子性时都会以银行转账为例：用户A向用户B转账100元。
转账事务请求中，银行会进行2项操作：A账户减少100元；B账户增加100元。
不管银行按什么顺序执行，如果2项操作进行到一半时失败了，银行都需要先进行回滚，否则就会出现错误（银行损失或用户A损失）。
换句话说，银行需要保障转账的原子性：这项请求要么成功，要么失败，不能出现任何中间状态（2个操作一个成功，一个失败）。
对应到计算机运行中，一些操作是原子性的，另一些操作是由若干原子性操作组合而成。
比如根据上面分析，i=i+1不是原子操作；那i=9是原子操作吗？如果计算机分别对i的高低16位先后赋值，那就不是原子操作。
可见性 可见性是指多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
比如：
// 线程A int i = 0 i = 5 // 线程B j = i 如果线程A执行完i = 5但尚未写入内存时，线程B从内存看到的i = 0，无法看到线程A缓存中i的值已经发生变化。
有序性 以下代码示例来自《七周七并发》
public class Puzzle { static boolean answerReady = false; static int answer = 0; static Thread t1 = new Thread() { @Override public void run() { answer = 42; answerReady = true; } }; static Thread t2 = new Thread() { @Override public void run() { if (answerReady) { System.……
        </div>
        <p class="readmore"><a href="https://axiomaster.gitee.io/post/2019-04-27-java-concurrent/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://axiomaster.gitee.io/post/2019-04-27-dlib/" title="静态库与动态库">静态库与动态库</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2019年3月17日
        </date>
        
        <div class="post-content">
            编译流程  编译生成可重定位目标文件，经链接器将其和依赖的库组合起来，生成可执行文件。
可执行文件运行时，经过加载器(loader)将其中的代码和和数据拷贝到内存，然后跳转到程序起始地址开始执行。
 链接 连接器主要完成2个任务
 符号解析：每个符号对应一个函数，全局变量或静态变量。符号解析将符号引用与符号定义关联起来。 重定位：编译器生成的可重定位目标文件中地址从0开始。链接器把多个库合并，将符号与内存地址关联，重定位这些节，并修改符号引用地址。  ELF文件  可执行可链接格式ELF(Executable and Linkable Format)
   静态库与静态链接 linux上静态库以存档（archive, .a后缀）文件格式存储，是一组可重定位目标文件的集合。
静态链接时，会将.a中对应的内容拷贝，最终生成的可执行文件中包含静态库内容。程序运行时不再依赖静态库。
动态共享库与动态链接  静态库内容需要拷贝到可执行文件中，生成目标文件比较大，占用空间（减少了运行时依赖，现在看也许是优势） 静态库不支持热更新  相比静态库，以上就是动态库的特点：允许多个进程在内存中共享同一份库代码。
位置无关代码  位置无关代码PIC(Position-Independent Code), 编译时需要指定-fpic参数
 显示调用 显示使用共享库时不需要依赖头文件，通过dlfcn.h中提供的API进行调用：
// 将动态库加载到内存 // 指定名称，在LD_LIBRARY_PATH、/lib、/usr/lib目录下查找 // 或指定全路径 void *dlopen(const char *libname,int flag); // 在动态库中查找对应函数 void *dlsym(void *handle,const char *symbol); // dlclose() // 获取最近一次error信息，调用后会清空最近的错误信息 char *dlerror(void); 显示调用，可以在运行时打开库函数进行调用，有点儿类似动态语言的效果；而且，在代码执行到dlopen之前，so可以不存在。
隐式调用 隐式调用时需要引用库对应的头文件，代码中直接调用头文件中声明的函数即可；编译时，通过-l指定需要链接的库。
但隐式调用，在可执行文件开始执行时，所有依赖的库必须存在，否则无法运行。
后记 又水一篇。
链接中ELF结构与《深入理解Java虚拟机》第6章 类文件结构简直神似，看这种内容就和看模电或高频里一大坨电路图一样，全是记都记不住的细节。果然还是脑袋缓存太小了，处理太慢了。……
        </div>
        <p class="readmore"><a href="https://axiomaster.gitee.io/post/2019-04-27-dlib/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://axiomaster.gitee.io/post/2019-03-23-bugs/" title="神奇的bug">神奇的bug</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2019年3月17日
        </date>
        
        <div class="post-content">
             状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
   Etcd启动失败
  数字排序问题
  golang defer导致内存溢出
  jpa事务读写
  CRL校验问题
  ……
        </div>
        <p class="readmore"><a href="https://axiomaster.gitee.io/post/2019-03-23-bugs/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://axiomaster.gitee.io/post/2019-03-17-state-pattern/" title="状态模式 State Pattern">状态模式 State Pattern</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2019年3月17日
        </date>
        
        <div class="post-content">
            状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
 工作中经常会遇到各种状态机，使用流程控制的方式虽然也可以实现，但后续的维护变动就变得很困难。在实际中我们现在就遇到了一个这样子的问题，整个状态机的代码有一千多行，代码完成的还算工整，但要看懂现在就只能对比状态图了，因为状态实在太多了。我曾经增改过两次，每次改动都伴随着一大堆的问题单。
这时候就真真切切体会到状态模式的好处了。
类图  状态模式 vs 策略模式 如果与策略模式的类图对比的话，会发现图结构几乎一模一样。虽然如此，这俩模式还是有比较明显的区别。
策略模式中，最后的每一个业务类只包含了一组算法中的一个实现；或者说每一种算法的组合形成了一个业务类。
但在状态模式中，业务类中继承了算法的所有实现，并且在运行态切换算法为不同的实现，从而让自己拥有不同的行为（表现为不同的状态）。
我觉得类比之前策略模式中不同种类鸭子的实现，状态模式只存在一只百变鸭，但这只鸭子根据外界输入一会将自己变成红头鸭吱吱叫，一会儿变成绿头鸭呱呱叫。
代码 略……
        </div>
        <p class="readmore"><a href="https://axiomaster.gitee.io/post/2019-03-17-state-pattern/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://axiomaster.gitee.io/post/2019-03-31-factory-pattern/" title="工厂模式 Factory Pattern">工厂模式 Factory Pattern</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2019年3月17日
        </date>
        
        <div class="post-content">
            工厂模式定义了一个创建对象的接口，但由子类决定要实例化的类时哪一个。工厂方法让类把实例化推迟到子类。
 简单工厂 简单工厂的思路也确实非常简单，就像将创建类的代码进行了简单的抽离。《设计模式》也说这不应该算一种模式，更像一种编程习惯。就好比撸完代码之后自己回头看看，发现这一块独立的逻辑可以抽离出来独立一下。
 工厂模式 工厂模式中，创建者与产品为平行类层级，只是创建者的创建方法产生产品。要创建哪种产品，由具体的创建者子类决定；产品的实际创建，也由产品的具体实现类完成。
 代码 略……
        </div>
        <p class="readmore"><a href="https://axiomaster.gitee.io/post/2019-03-31-factory-pattern/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://axiomaster.gitee.io/post/2019-04-21-gradle-proxy/" title="使用Gradle开发IDEA插件">使用Gradle开发IDEA插件</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2019年3月17日
        </date>
        
        <div class="post-content">
            最近想试着开发一个IDEA的插件，官方指导 中有两种方式:
 使用Gradle 使用DevKit  而且官方推荐Gradle的方式，称DevKit的工作流已经过时了。但百度出来的全都是DevKit的方式。而且Android Studio也是gradle，那就试试gradle的方式开发一个插件。
Gradle配置 使用gradle创建工程之后，需要下载一些文件，因为GWF的原因这一步会特别慢，不使用VPN基本都失败了。网上找了使用aliyun源的方式，搞定了这一步。
单个工程修改 将工程下build.gradle中的repositories替换为如下内容
repositories { maven { url &#39;https://maven.aliyun.com/repository/public/&#39; } maven { url &#39;https://maven.aliyun.com/repository/google/&#39; } maven { url &#39;https://maven.aliyun.com/repository/jcenter&#39; } } 具体替换地址可以看aliyun官网的地址，网上大多数配置都没有更新，使用的还是旧地址。
全局配置 以上方式只修改单个工程的，每次新建工程都要修改，很麻烦。下面这个方法可以修改全局的配置。
在 C:\Users\用户名\.gradle目录下创建init.gradle文件，内容如下：
allprojects { repositories { maven { url &#39;https://maven.aliyun.com/repository/public/&#39; } maven { url &#39;https://maven.aliyun.com/repository/google/&#39; } maven { url &#39;https://maven.aliyun.com/repository/jcenter&#39; } all { ArtifactRepository repo -&gt; if (repo instanceof MavenArtifactRepository) { def url = repo.url.toString() if (url.startsWith(&#39;https://repo.maven.apache.org/maven2/&#39;) || url.……
        </div>
        <p class="readmore"><a href="https://axiomaster.gitee.io/post/2019-04-21-gradle-proxy/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://axiomaster.gitee.io/post/2019-03-22-simple/" title="一道数学题">一道数学题</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2019年3月17日
        </date>
        
        <div class="post-content">
            我女朋友从中学时数学就不咋样，高中时理科太差就只能读文科，读了文科数学依然最差。大学数学还需要补考才能毕业，考研时因为不考数学才读的现在的专业。我略好一些，高中时借着给她补习数学才走到一起。
这是背景。
前一阵子和女朋友去买鞋，商场满减，400减100，700减200，900减300。我们选中了一双700多一点儿的鞋，刚好凑够满减。付钱的时候，收银台有个大姐，选了一条裤子200多，要和我们一起凑单。
我想都没想就说可以啊。这时候我女朋友突然问，那怎么凑？她这么突兀的一问，我还没反应过来。大姐也呆住了，就说你们减200，我们减100啊。我女朋友就有点儿吞吞吐吐了，我们已经够减200了之类的。大姐见势不妙，就让一步说那你们减220，自己减80。听到这里我都有点儿不好意思了，刚好收银员也扫好了码催付款。我赶紧付了钱，收了大姐的余额就往出走。大姐的丈夫过来后了解清楚了，就在背后说互利互惠什么的。
走出门的时候，我总觉得自己占了人家20块钱的便宜，心理有点儿内疚。我女朋友却说，她本想着我们减250，他们减50。看我一脸震惊，就跟我开始算起了帐。我们700多，不需要他们也能优惠200；他们没我们，啥优惠也没有；加一起之后，多优惠了100，那这100按比例我们应该70，他们30，至少也得平分。
至此我才突然转过弯儿来，从头至尾我不仅没占人家便宜，还被别人占了便宜。……
        </div>
        <p class="readmore"><a href="https://axiomaster.gitee.io/post/2019-03-22-simple/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://axiomaster.gitee.io/post/2019-04-14-defer/" title="Golang defer导致内存溢出">Golang defer导致内存溢出</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2019年3月17日
        </date>
        
        <div class="post-content">
            Golang中提供了defer关键字，以前可能需要在函数内进行多次判断之后释放资源，现在使用defer一次就搞定了，习惯之后会觉得这个特性非常好用。
问题代码 有一句话是软件设计没有银弹，放在这里依然成立。defer这么好用，但也需要注意一些坑。代码逻辑大致如下：
for { defer 释放资源 // http request  // 错误码判断  // sleep 5s重试 或 break退出 } 业务是心跳这样的守护进程，所以直接就用了死循环，请求失败之后进行重试，或满足一定条件时退出循环。使用defer在最后释放资源。
测试时异常场景也进行了覆盖，功能上没有发现问题。但在一个实例上发现运行一段时间之后内存爆了。
问题分析 defer的实现机制是在调用函数栈上再压入defer函数，调用return前调用defer函数。所以调用defer会有一次压栈操作。
上面的示例中将defer在for循环中，环境恰好没有返回对应的错误码让for循环退出，导致defer一直被执行，重复的压栈导致StackOverflow。
小结 从这里看，将defer放入循环中就是一个不好的习惯；另外，死循环代码也有一丝丝坏味道，看到这样的代码时就应该警惕了。……
        </div>
        <p class="readmore"><a href="https://axiomaster.gitee.io/post/2019-04-14-defer/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://axiomaster.gitee.io/post/2019-03-05-strategy-pattern/" title="策略模式 Strategy Pattern">策略模式 Strategy Pattern</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2019年3月3日
        </date>
        
        <div class="post-content">
            策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。
 类图  继承 vs 组合 上面的描述有些抽象。策略模式想要表达的是，如果一个类需要某种行为，不要通过继承来实现（is-a），可以使用组合（has-a）来实现。这样做更加灵活，当业务类（duck）的行为（fly）需要改变时，只需要注入不同的算法实现类即可。
这也就是 鸭子继承， 如果一个类通过组合获取了鸭子的行为，那它就可以当作鸭子使用，不需要关注它是否继承自鸭子基类，是否真正的是一只鸭子。
Java中Spring的依赖注入（DI）也是这种思路。Golang中甚至取消了继承，从语法层面避免继承所带来的耦合。这里甚至可以推测，OOP在提出之初，只是基于对真实世界中对象建模的思路，提出了继承，实现等概念。但后续工程实践发现继承并没有组合好用。
很多协议设计也是这样，基于最初的构想设计了很多特性，结果后续使用中发现一部分设计很鸡肋或很容易出错。于是又通过各种约定，最佳实践，框架等来解决这些问题。
代码 public interface FlyBehavior { void fly(); } class FlyWithWings implements FlyBehavior { @Override public void fly() { // todo  } } class FlyNoWay implements FlyBehavior { @Override public void fly() { // do nothing  } } public interface QuackBehavior { void quack(); } class Quack implements QuackBehavior { @Override public void quack() { // todo  } } class Squeak implements QuackBehavior { @Override public void quack() { // todo  } } class MuteQuack implements QuackBehavior { @Override public void quack() { // todo  } } public abstract class Duck { FlyBehavior flyBehavior; QuackBehavior quackBehavior; abstract void display(); void performFly() { flyBehavior.……
        </div>
        <p class="readmore"><a href="https://axiomaster.gitee.io/post/2019-03-05-strategy-pattern/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://axiomaster.gitee.io/post/2019-03-03-plantuml/" title="工具篇">工具篇</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2019年3月3日
        </date>
        
        <div class="post-content">
            曾经信心满满的立过很多flag，要学习并掌握某一领域或坚持某件事儿，最终都无疾而终，只剩下零星概念和一堆遗憾，原因大都类似：
 计划被其它事情打断，中止了 进行到一半，发现意义不大 进行中遇到了困难，放弃了 当时掌握了，但没有及时总结，后续没有练习，忘记了  包括不限于协议栈、数据库、JVM、正则表达式、音律、写总结&hellip;&hellip;也包括设计模式。结果一回头，猛然发现时间已经过去了这么久，却什么都没有留下来。
在此再立一个flag，每周写一篇总结。周积跬步，以致千里。
UML  统一建模语言 (Unified Modeling Language, UML)
 所有介绍设计模式的资料都会用到uml图。之前总以为UML图就是类图，每次都是被继承，实现里面的实线、虚线、箭头等给整懵了。然后就放弃看图，只看代码实现。
现在才知道，类图只是UML中的一小部分。UML图还包括用例图，时序图等。和SE等大佬交流时，设计文档里全是各种UML图。
PlantUML 各种工具都可以画UML图，包括visio，Visual Paradigm等。我们使用PlantUML, 像Markdown一样，通过简单的语句写UML图，使用方便。当然，这一套工具也都是免费的。
windows安装  PlantUML  PlantUML有IntelliJ IDEA的插件版，可以直接在IDEA的plugins中下载安装。我们也使用这个版本。
 插件装好之后，新建puml文件，直接打开就可以看到对应的编辑器了。
  Graphviz  安装插件之后，也可能无法看到右边的预览图，而是提示报错，这是因为缺少Graphviz环境变量。Graphviz是一个开源的绘图软件，很多开源软件生成可视化图时都使用Graphviz。
下载Graphviz并安装后，配置如下环境变量之后就好了。
GRAPHVIZ_DOT=D:\Program Files (x86)\Graphviz2.38\bin\dot.exe PlantUML基本语法  PlantUML类图
  泛化，Generalization 关联，Association 组合，Composition 聚合，Aggregation 实现，Realization 依赖，Dependency  @startuml Class01 &lt;|-- Class02:泛化 Class03 &lt;-- Class04:关联 Class05 *-- Class06:组合 Class07 o-- Class08:聚合 Class09 &lt;|.. Class10:实现 Class11 &lt;.. Class12:依赖 @enduml   ……
        </div>
        <p class="readmore"><a href="https://axiomaster.gitee.io/post/2019-03-03-plantuml/">阅读全文</a></p>
    </article>
    
    
    



<ol class="page-navigator">
    
    <li class="prev">
        <a href="https://axiomaster.gitee.io/post/page/3/">上一页</a>
    </li>
    

    
    <li >
        <a href="https://axiomaster.gitee.io/post/">1</a>
    </li>
    
    <li >
        <a href="https://axiomaster.gitee.io/post/page/2/">2</a>
    </li>
    
    <li >
        <a href="https://axiomaster.gitee.io/post/page/3/">3</a>
    </li>
    
    <li  class="current">
        <a href="https://axiomaster.gitee.io/post/page/4/">4</a>
    </li>
    
    <li >
        <a href="https://axiomaster.gitee.io/post/page/5/">5</a>
    </li>
    
    <li >
        <a href="https://axiomaster.gitee.io/post/page/6/">6</a>
    </li>
    
    <li >
        <a href="https://axiomaster.gitee.io/post/page/7/">7</a>
    </li>
    
    <li >
        <a href="https://axiomaster.gitee.io/post/page/8/">8</a>
    </li>
    

    
    <li class="next">
        <a href="https://axiomaster.gitee.io/post/page/5/">下一页</a>
    </li>
    
</ol>



</div>

                    <footer id="footer">
    <div>
        &copy; 2022 <a href="https://axiomaster.gitee.io/">Axiomaster&#39;s Site By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>



<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>






                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='//www.google.com/search' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://axiomaster.gitee.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-12-26-protected_mode-addition/" title="保护模式补充">保护模式补充</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-12-19-page/" title="内存分页">内存分页</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-12-18-protected_mode/" title="保护模式">保护模式</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-12-04-os-loader-addition/" title="确认软盘内容执行">确认软盘内容执行</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-11-22-os-loader/" title="读取并执行软盘内容">读取并执行软盘内容</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-11-21-os-boot-addition/" title="启动补充说明">启动补充说明</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-11-17-os-boot/" title="从上电到引导扇区">从上电到引导扇区</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2021-10-31-gcc-inline-asm/" title="GCC Inline ASM">GCC Inline ASM</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2020-09-03-tensorflow2_2/" title="Tensorflow2.0 笔记（2）">Tensorflow2.0 笔记（2）</a>
    </li>
    
    <li>
        <a href="https://axiomaster.gitee.io/post/2020-09-07-tensorflow2_3/" title="Tensorflow2.0 笔记（3）">Tensorflow2.0 笔记（3）</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="https://axiomaster.gitee.io/tags/activity/">activity</a>
    
    <a href="https://axiomaster.gitee.io/tags/algorithm/">algorithm</a>
    
    <a href="https://axiomaster.gitee.io/tags/android/">android</a>
    
    <a href="https://axiomaster.gitee.io/tags/aosp/">aosp</a>
    
    <a href="https://axiomaster.gitee.io/tags/bazel/">bazel</a>
    
    <a href="https://axiomaster.gitee.io/tags/bug/">bug</a>
    
    <a href="https://axiomaster.gitee.io/tags/debug/">debug</a>
    
    <a href="https://axiomaster.gitee.io/tags/debugger/">debugger</a>
    
    <a href="https://axiomaster.gitee.io/tags/docker/">docker</a>
    
    <a href="https://axiomaster.gitee.io/tags/golang/">golang</a>
    
    <a href="https://axiomaster.gitee.io/tags/gradle/">Gradle</a>
    
    <a href="https://axiomaster.gitee.io/tags/i/o/">I/O</a>
    
    <a href="https://axiomaster.gitee.io/tags/idea%E6%8F%92%E4%BB%B6/">IDEA插件</a>
    
    <a href="https://axiomaster.gitee.io/tags/java/">java</a>
    
    <a href="https://axiomaster.gitee.io/tags/linux/">linux</a>
    
    <a href="https://axiomaster.gitee.io/tags/ml/">ML</a>
    
    <a href="https://axiomaster.gitee.io/tags/net/">net</a>
    
    <a href="https://axiomaster.gitee.io/tags/nginx/">nginx</a>
    
    <a href="https://axiomaster.gitee.io/tags/os/">OS</a>
    
    <a href="https://axiomaster.gitee.io/tags/tensorflow/">Tensorflow</a>
    
    <a href="https://axiomaster.gitee.io/tags/tool/">tool</a>
    
    <a href="https://axiomaster.gitee.io/tags/view/">view</a>
    
    <a href="https://axiomaster.gitee.io/tags/window/">window</a>
    
    <a href="https://axiomaster.gitee.io/tags/zookeeper/">zookeeper</a>
    
    <a href="https://axiomaster.gitee.io/tags/zygote/">zygote</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E5%86%85%E5%AD%98/">内存</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E5%90%90%E6%A7%BD/">吐槽</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E5%B7%A5%E5%85%B7/">工具</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E5%B9%B6%E5%8F%91/">并发</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E6%89%8B%E5%B7%A5/">手工</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E6%89%AF%E6%B7%A1/">扯淡</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E6%97%A5%E5%B8%B8/">日常</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E7%94%9F%E6%B4%BB/">生活</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E7%A5%9E%E5%A5%87%E7%9A%84bug/">神奇的bug</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E8%AF%81%E4%B9%A6/">证书</a>
    
    <a href="https://axiomaster.gitee.io/tags/%E9%93%BE%E6%8E%A5/">链接</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://axiomaster.gitee.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Axiomaster&#39;s Site</title>
    <link>https://axiomaster.github.io/post/</link>
    <description>Recent content in Posts on Axiomaster&#39;s Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 Jan 2022 18:18:29 +0800</lastBuildDate>
    
	<atom:link href="https://axiomaster.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>c语言补充说明</title>
      <link>https://axiomaster.github.io/post/2022-01-08-c-language-addition/</link>
      <pubDate>Sat, 08 Jan 2022 18:18:29 +0800</pubDate>
      
      <guid>https://axiomaster.github.io/post/2022-01-08-c-language-addition/</guid>
      <description>1-1 从上电到引导扇区 1-2 启动补充说明 2-1 读取并执行软盘内容 2-2 确认软盘内容执行 3-1 保护模式 3-2 内存分页 3-3 保护模式补充 4-1 引入c语言  稍有经验的同学肯定知道，编译得到的二进制文件中有text, bss, data, rodata等段。我们今天试着剖析一下这些概念。
segment &amp;amp; section segment和section在中文某些场景下都被翻译成段，很容易搞混。我们今天这里不再翻译，直接使用这两个词。
代码经编译器编译链接后得到ELF文件，操作系统将ELF文件加载至内存中并运行。这里涉及到2个过程，链接与装载。
 代码编译得到可重定位文件(.o)后，链接器(ld)对可重定位文件中的符号进行地址重定位，并最终得到可执行文件。 操作系统将可执行文件通过分页机制加载至内存之后执行。加载时，不同的页对应的属性（访问权限）不同，比如代码部分是只读可执行的，其它段是可写的等。  ELF文件作为2个过程的桥梁，就存在链接视图（Linking View）和执行视图（Execution View）两种视图。其中，section对应链接过程，segment对应装载（运行）过程。
链接时，根据不同的功能，ELF文件会划分位多个section。装载时，操作系统以页（4K）为单位进行，如果不足一个页，也要进行对齐。这时如果有多个section，每个section占用1个页，几乎每个section都会在对齐时导致一部分内存空间浪费。而对于操作系统来说，只关注每个page的读写等属性。所以操作系统就将相同读写书写的section对应为一个segment进行加载。
readelf -l可以查看section与segment对应关系：
 ELF文件格式  ELF header ELF header格式是固定的，在/usr/include/elf.h中有定义：
/* The ELF file header. This appears at the start of every ELF file. */ #define EI_NIDENT (16)  typedef struct { unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */ Elf32_Half	e_type;	/* Object file type */ Elf32_Half	e_machine;	/* Architecture */ Elf32_Word	e_version;	/* Object file version */ Elf32_Addr	e_entry;	/* Entry point virtual address */ Elf32_Off	e_phoff;	/* Program header table file offset */ Elf32_Off	e_shoff;	/* Section header table file offset */ Elf32_Word	e_flags;	/* Processor-specific flags */ Elf32_Half	e_ehsize;	/* ELF header size in bytes */ Elf32_Half	e_phentsize;	/* Program header table entry size */ Elf32_Half	e_phnum;	/* Program header table entry count */ Elf32_Half	e_shentsize;	/* Section header table entry size */ Elf32_Half	e_shnum;	/* Section header table entry count */ Elf32_Half	e_shstrndx;	/* Section header string table index */ } Elf32_Ehdr;  e_entry就是程序总入口地址 e_phoff对应程序头表（Program header table）在文件中的偏移量 e_phentsize程序头表中每个条目（entry）的大小 e_phnum程序头表中条目数量，对应segment个数  Program header table 程序头表（Program header table）保存运行视图中的segment信息。</description>
    </item>
    
    <item>
      <title>中断</title>
      <link>https://axiomaster.github.io/post/2022-01-08-interrupt/</link>
      <pubDate>Sat, 08 Jan 2022 18:18:29 +0800</pubDate>
      
      <guid>https://axiomaster.github.io/post/2022-01-08-interrupt/</guid>
      <description> 1-1 从上电到引导扇区 1-2 启动补充说明 2-1 读取并执行软盘内容 2-2 确认软盘内容执行 3-1 保护模式 3-2 分页 3-3 保护模式补充 4-1 c语言 4-2 c语言补充  </description>
    </item>
    
    <item>
      <title>引入c语言</title>
      <link>https://axiomaster.github.io/post/2022-01-01-c-language/</link>
      <pubDate>Sat, 01 Jan 2022 22:56:29 +0800</pubDate>
      
      <guid>https://axiomaster.github.io/post/2022-01-01-c-language/</guid>
      <description>1-1 从上电到引导扇区 1-2 启动补充说明 2-1 读取并执行软盘内容 2-2 确认软盘内容执行 3-1 保护模式 3-2 内存分页 3-3 保护模式补充  编译过程 前面我们都是使用汇编进行编程，从这节开始引入c语言进行编写。我们知道C语言相对汇编语言，属于高级语言(^_^)。高级语言是需要编译成机器语言才可以执行的。为了让编译器编译得到的结果能够方便的在操作系统上执行，操作系统定义了二进制可执行文件的格式。linux上使用的就是ELF文件格式。
我们这次只是开发操作系统，没有做自己的C编译器，还是要使用gcc等编译器。所以我们的操作系统就要去兼容gcc编译得到的ELF文件结果。历史上，gcc也是在linux操作系统之前被开发出来的。
 #include &amp;lt;stdio.h&amp;gt; int main() { printf(&amp;#34;hello world\n&amp;#34;); return 0; } 我们用hello world走一遍这个流程。
我的环境是64位的，我们要编译32位的结果，所以中间会有一些特殊的编译选项。为了省事儿，也可以搭建32位的开发编译环境。
 预处理 gcc -E hello.c -o hello.i 我们可以看到，7行的hello.c源文件经过预处理后，得到了733行的hello.i的文本文件。
编译器 gcc -S hello.i -o hello.s -m32 编译后得到了hello.s的汇编代码。这里，-m32是为了指定得到32位的结果，否则一些寄存器长度会错误。
汇编器 gcc -c hello.s -o hello.o -m32 经汇编之后，得到的是ELF 32-bit LSB relocatable 文件。
链接 ld -m elf_i386 hello.o -lc -e main 链接之后，得到的就是ELF 32-bit LSB executable可执行文件。</description>
    </item>
    
    <item>
      <title>保护模式补充</title>
      <link>https://axiomaster.github.io/post/2021-12-26-protected_mode-addition/</link>
      <pubDate>Sun, 26 Dec 2021 14:15:29 +0800</pubDate>
      
      <guid>https://axiomaster.github.io/post/2021-12-26-protected_mode-addition/</guid>
      <description>1-1 从上电到引导扇区 1-2 启动补充说明 2-1 读取并执行软盘内容 2-2 确认软盘内容执行 3-1 保护模式 3-2 内存分页  保护 前面讲过，保护模式的保护，是指CPU在进行内存跳转、访问时，增加了很多检查，确保内存访问安全。在分段和分页机制中，我们也看到了，段选择子，段描述符等都有很多的权限相关的标记位，CPU就是根据这些标记位及一系列访问规则判断是否有权限访问的，即进行内存保护。
数据段&amp;amp;代码段 段描述符中的S位（44位），表明段描述符的类型：
 S=0, 系统段/门描述符 S=1, 数据段/代码段  段描述符中的TYPE位（40~43位），表明段描述符的类型。一个段可能为：
   TYPE值 数据段/代码段 系统段/门描述符     0 只读 未定义   1 只读,已访问 可用286 TSS   2 读/写 LDT   3 读/写，已访问 忙的286 TSS   4 只读，向下扩展 286 调用门   5 只读，向下扩展，已访问 任务门   6 读/写，向下扩展 286 中断门   7 读/写，向下扩展，已访问 286 陷阱门   8 只执行 未定义   9 只执行、已访问 可用386 TSS   A 执行/读 未定义   B 执行/读、已访问 忙的386 TSS   C 只执行、一致代码 386 调用门   D 只执行、一致代码、已访问 未定义   E 执行/读、一致代码 286 中断门   F 执行/读、一致代码、已访问 386 陷阱门    从这么多种类型定义中，可以预期整个检查规则很复杂（@_@）。其中门描述符（gate）用于中断发生时的检查，CPU确认特权级等设定符合约束后，才能进入相应的处理程序。</description>
    </item>
    
    <item>
      <title>内存分页</title>
      <link>https://axiomaster.github.io/post/2021-12-19-page/</link>
      <pubDate>Sun, 19 Dec 2021 15:00:29 +0800</pubDate>
      
      <guid>https://axiomaster.github.io/post/2021-12-19-page/</guid>
      <description>1-1 从上电到引导扇区 1-2 启动补充说明 2-1 读取并执行软盘内容 2-2 确认软盘内容执行 3-1 保护模式  逻辑地址，线性地址，物理地址 程序编译后，程序内部使用的地址是段内偏移量，这个地址是逻辑地址。
程序加载运行时，操作系统负责多个程序的调度。程序使用的段内偏移量（逻辑地址），加上段内偏移量，就是线性地址。
如果没有分页机制，那线性地址=物理地址。启用分页机制之后，线性地址通过转换，才能对应为物理地址。
 因此，逻辑地址经过分段机制转换后，得到线性地址；再经过分页机制转换后，得到物理地址。
分页 为什么要分页 段的长度不定,在分配内存时,可能会发生内存中的空闲区域小于要加载的段,或者空闲区域远远大于要加载的段。在前一种情况下,需要另外寻找合适的空闲区域;在后一种情况下,分配会成功,但太过于浪费。为了解决这个问题,从386开始,引入了分页机制。分页功能从总体上来说,是用长度固定的页来代替长度不一定的段,藉此解决因段长度不同而带来的内存空间管理问题。
页框，页表，页目录表 操作系统将线性地址按固定大小组织，每一份称之为一页（page）。页大小可以为4K，1M等，一般为4KB。物理地址按照同样大小进行划分，称为页框（frame）。操作系统需要记录线性地址与物理地址的映射关系，这个关系就记录在页表（page table）中。页表中的每一项称为PTE。
实际中，为了节省内存，会使用多级页表，即为页表再创建一个页目录表（page direcotry table）。页目录表中每的一项，称之为PDE，都指向不同的页表。
 分页寻址 逻辑地址经过分段后，得到32位的线性地址。启用分页机制后，32位的线性地址会再次划分为3部分，分别表示
 22~31位：指向页目录表中的某一项PDE 12~21位：指向具体某个页表中的某一项 0~11位：页内偏移量   假设我们采用2级页表，我们可以计算一下：
 每个页大小4KB，12位的业内偏移量恰好可以寻址4KB偏移地址。 22~31位共10位，最多可以表示1024个不同值，因此页目录表最多只能有1024个PDE 同理，12~21位共10位，对应页表最多页也只能有1024个PTE 1024个PDE * 1024个PTE * 4KB = 4GB，分页之后能够寻址的最大空间还是4GB   启用分页机制 启用分页机制，需要进行如下3步操作：
 创建页表 将cr3寄存器设置为页目录表地址 将cr0寄存器pg位置1  内存布局设计 现在的内存布局是我从其它地方抄来的。
 截图中显示了页目录表，及第1页表。
 页目录表中的第0项及第768项，均对应第1页表。 页目录表中第1023项（即最后一项），对应页目录表本身。 第1页表，只填写了0~255项，对应1M（4K*256）物理内存。  页目录表第0项表示线性地址最开端的4M地址，页目录表第768项对应线性地址3G开始的4M内存。均对应第1页表。当前我们在第1页表只填充了1M内存。所以线性地址开始的1M内存（0~1M）与3G开始的1M内存（3G~3G+1M），对应同一块物理内存。
这样划分，是因为之前所有的代码都是在线性地址的开始（0~1M）内存实现的。但我们会将4G内存空间划分为用户空间（0~3G）和内核空间（3G~4G）。通过将页目录表第0项与第768项指向同一块内存，则可以在使用线性地址3G以上的内核空间地址继续访问之前的1M内存。
测试 测试方法和以前相同，通过在屏幕打日志的方式判断是否执行成功。</description>
    </item>
    
    <item>
      <title>保护模式</title>
      <link>https://axiomaster.github.io/post/2021-12-18-protected_mode/</link>
      <pubDate>Sat, 18 Dec 2021 09:45:29 +0800</pubDate>
      
      <guid>https://axiomaster.github.io/post/2021-12-18-protected_mode/</guid>
      <description>1-1 从上电到引导扇区 1-2 启动补充说明 2-1 读取并执行软盘内容 2-2 确认软盘内容执行  CPU保护模式 我们知道，操作系统是对计算机各种硬件资源进行管理的，通过提供各种API，方便各种应用使用计算机硬件完成各自功能。因此，开发操作系统需要受硬件实现限制，也可以理解为按照硬件接口约定调用硬件能力。比如启动扇区的最后两个字节必须是0xAA 0x55，这就是一种约定，不这样做就没法正常启动。对于386指令集的CPU，这样的硬件接口约定和指导汇总就是《Intel 80386 程序员参考手册》。
随着CPU功能的日益强大，这种硬件上的约定越来越多，其中很多还是特定历史原因造成的，或为了保持兼容性而设计的。这就导致我们需要了解的细节很多，而且不会很直观。保护模式就是实现操作系统过程中将会遇到的第一座大山，因为我们要借助CPU硬件能力实现。
实模式&amp;amp;保护模式 我们前面访问内存是采用的[CS:IP]=CS&amp;lt;&amp;lt;4+IP的方式就是实模式下的内存寻址方式。Intel 8086 CPU只有16位，到了80386时代（286存在时间很短），CPU进入了32位，这时再也不能采用之前8086 16位CPU的寻址方式了。同时，Intel在硬件设计中加入了很多内存访问检查等保护机制。为了与之前的CPU特性区分，Intel将8086对应的16位运行模式称为实模式，将386及之后的x86CPU对应的32位运行模式称为保护模式。
因为x86CPU是兼容之前8086CPU的，而且x86CPU启动后默认运行在实模式下。这也是为什么我们前面的代码放在最新的x86CPU上也可以运行的很happy的原因。
保护模式寻址方式 保护模式下，CPU分段寻址方式与实模式不再相同。操作系统将内存进行分段，并将分段信息以数组的形式存储在内存中。数组的每一项对应一个分段信息，称为段描述符（Segment Descriptor），这个数组被称之为段描述符表。全局有一个总的段描述符表，称为全局段描述符表（GDT），当然，也有局部段描述符表（LDT）。
可以想想，所有的内存寻址都需要通过GDT表进行，为了加速内存寻址，CPU提供了GDTR寄存器用于存储GDT对应的内存起始地址。同时，CPU提供了LGDT指令用于将GDT的内存起始地址加载到GDTR寄存器中。
有了全局段描述符表GDT，段寄存器中的值就不再像实模式下那样，是段的起始地址了。而是用来筛选出GDT表中对应的某一项的，称之为段选择子（Segment selector）。
这样，保护模式下的寻址方式大概如下：
 操作系统开发者在内存中按格式创建出GDT 操作系统启动后通过LGDT指令将内存中GDT的起始地址加载到GDTR中 寻址时，[CS:IP]中，段寄存器的值被CPU理解为段选择子，通过CPU某些运算检查，从GDTR中找出某一项段描述符 段描述符通过CPU某些运算检查，得到段基址，加上偏移地址，得到最终地址结果  怎么样，被这些概念绕晕了吧？ ^_^
保护 也许你会好奇，第3步的段选择子不应该就是一个数组下标吗？第4步中的段描述符不就是一个内存起始地址吗？如果让我来设计CPU，我也会这么干。但历史上，从8086到80386发展过程中，也许发生了很多因为内存访问导致的bug，导致Intel决定，在CPU中设计一套内存访问控制，权限检查机制。
因此，第3步段选择子除了数组下表的功能外，还存储了一些其它用于内存访问检查的信息，第4步段描述符除了存储内存起始地址，也存储了其它对应信息。这些信息在内存访问时，CPU会按照设计规则对齐进行检查，防止非法访问。这也就是保护模式中所谓的保护的意思。
数据结构 段描述符  段选择子  GDTR寄存器  从实模式到保护模式 从实模式切换到保护模式，要进行如下3步操作，这些操作都是Intel CPU要求的。
 打开A20 Gate 加载GDT 将CR0的PE位置1  A20 Gate历史背景 8086下，CPU是16位的，地址总线20位，对应1M内存。当程序访问大于1M的地址时，系统会贴心的对地址按1M求模。这个技术称为wrap-around。
到了保护模式，我们需要访问大于1M的内存，需要关闭wrap-around机制。而这个机制，因为历史原因，被键盘控制器上的第21根地址线（A20 Gate）控制。当打开A20 Gate时，才能突破1M的内存限制。
创建并记载GDT 我们将内存空间划分为3个段。根据规定，第1个段必须为空。因为GDT中4项如下：
;0描述符  dd 0x00000000 dd 0x00000000 ;1描述符(4GB代码段描述符)  dd 0x0000ffff dd 0x00cf9800 ;2描述符(4GB数据段描述符)  dd 0x0000ffff dd 0x00cf9200 ;3描述符(28Kb的视频段描述符)  dd 0x80000007 dd 0x00c0920b lgdt_value: dw $-gdt-1 ;高16位表示表的最后一个字节的偏移（表的大小-1）  dd gdt ;低32位表示起始位置（GDT的物理地址） 跳转至32位模式 protect_mode: ;进入32位 lgdt [lgdt_value] in al, 0x92 or al, 0000_0010b out 0x92, al cli mov eax, cr0 or eax, 1 mov cr0, eax jmp dword SELECTOR_CODE:main [bits 32] ;正式进入32位 main: 测试 64位视频段描述符，我们展开后如下图：</description>
    </item>
    
    <item>
      <title>确认软盘内容执行</title>
      <link>https://axiomaster.github.io/post/2021-12-04-os-loader-addition/</link>
      <pubDate>Sat, 04 Dec 2021 09:17:29 +0800</pubDate>
      
      <guid>https://axiomaster.github.io/post/2021-12-04-os-loader-addition/</guid>
      <description>1-1 从上电到引导扇区 1-2 启动补充说明 2-1 读取并执行软盘内容  上一节我们根据内存地址推算，确定0xc400位置保存着我们存储在软盘中的sys.bin内容，并跳转到这个地址位置开始执行。但我们如何确认代码正确执行了呢？
hlt指令 CPU负载 当前在sys.bin中只有一个死循环，如果程序中出现一个死循环，那会将所有空闲CPU资源占满，即运行死循环的CPU负载会飙到100%。在真实机器上这点可能不好确认，但如果在虚拟机中运行操作系统，我们可以很容易的在宿主机上观察到这点。
 hlt指令 当前我们的OS还没有任何实质性业务，就这样空跑CPU比较浪费。hlt指令就是为了解决这个问题的，它可以使CPU进入暂停状态，不执行任何操作。
我们修改sys.asm代码如下，在死循环中插入hlt指令。
org 0xc400 fin: hlt jmp fin 再试试效果：
bochs Debug 我们使用bochs虚拟机来运行我们写的OS，bochs提供了很多调试功能，可以看到cpu寄存器，内存等实时的数据。这样可以更直观的看到我们的OS运行情况。
这里我们用到两个调试命令:
 打断点 b 0xc400 反编译内存内容 u /10  使用b在0xc400处设置断点，运行后断点命中：
 命中断点后，使用反编译指令u反编译0xc400开始的2行代码，可以看到，与我们写的内容基本一致。
 跳转指令不完全一致，但可以猜到是给予当前行$-3位置处。
添加打印 我们也可以通过在sys.asm调用BIOS的打印中断int 10h来往屏幕写内容，确认代码是否执行成功。
mov ax, 0xb800 mov gs, ax mov byte [gs:0xa0],&#39;s&#39; mov byte [gs:0xa2],&#39;y&#39; mov byte [gs:0xa4],&#39;s&#39;  可以看到，sys.asm中的打印代码成功输出了，因此可以确认sys.asm已经被正确执行了。</description>
    </item>
    
    <item>
      <title>读取并执行软盘内容</title>
      <link>https://axiomaster.github.io/post/2021-11-22-os-loader/</link>
      <pubDate>Mon, 22 Nov 2021 23:17:29 +0800</pubDate>
      
      <guid>https://axiomaster.github.io/post/2021-11-22-os-loader/</guid>
      <description>1-1 从上电到引导扇区 1-2 启动补充说明  根据前面的内容我们知道，上电之后，根据CPU硬件电路设计，会自动将软盘第1扇区加载并执行。如果我们实现的OS只需要使用512个字节的代码，那就不需要主动读取软盘，只依靠CPU的硬件设计自动读取第1扇区就可以了。但这显然不可能。
所以接下来，我们就依靠第1扇区这512个字节的代码量，读取更多的软盘内容。
读取软盘内容至内存 我们将自己写的操作系统的代码编译成二进制文件后，存储在软盘上。然后利用第1个扇区的代码（开机后被BIOS自动加载至0x7c00处并开始执行），将软盘上的内容拷贝到内存中。拷贝完成后，再跳转到我们拷贝的目的内存地址，开始执行。
软盘的结构  上图来自《30天自制操作系统》
从上图中，我们可以看到，软盘有一圈有18个扇区Sector，从外向内分为80个柱面Cylinder，正反两面分别对应不同的磁头Heads来读写，这称之为CHS寻址模式，对应三部分的首字母。前面提到每个扇区可以存储512个字节，所以整个软盘共可以存储512*80*18*2=1440KB
读取1个扇区 通过调用BIOS int 13中断，可以读取软盘数据，调用代码如下：
MOV AX, 0x0820 ; 内存目的地址 0x08200  MOV ES, AX MOV CH, 0 ; 柱面0  MOV DH, 0 ; 磁头0  MOV CL, 2 ; 扇区2  MOV AH, 0x02 ; AH=0x02 : 读盘  MOV AL, 1 ; 1个扇区  MOV BX, 0 MOV DL, 0x00 ; A驱动器  INT 0x13 ; 调用BIOS int 13中断 读取10个柱面 如果上面的代码封装为一个函数，那读取整个软盘的逻辑用c语言描述大约如下：</description>
    </item>
    
    <item>
      <title>启动补充说明</title>
      <link>https://axiomaster.github.io/post/2021-11-21-os-boot-addition/</link>
      <pubDate>Sun, 21 Nov 2021 23:06:29 +0800</pubDate>
      
      <guid>https://axiomaster.github.io/post/2021-11-21-os-boot-addition/</guid>
      <description>1-1 从上电到引导扇区 1-2 启动补充说明  清理屏幕 上一节我们通过在显存地址直接写入字符，打印除了“hello”。但因为显存内存储着BIOS启动过程中的一些显示信息，所以屏幕看着很乱。这一节我们在打印字符之前，先讲显存内的内容清空，再进行打印，这样看着清爽些。
清空显存，当然有个笨办法，就是像打印“hello”一样，从0xb8000开始，向显存写入空白或不可见字符。但这个比较累。还有一个办法就是调用bios提供的int 10中断。
int10中断 org 07c00h ; 告诉编译器程序加载到7c00处  ;----中断10h，卷屏，实现清屏 mov ax, 0x0600 mov bx, 0x0700 mov cx, 0 mov dx, 0x184f int 0x10 ;----直接往显存中写数据 mov ax, 0xb800 mov gs, ax mov byte [gs:0x00],&amp;#39;h&amp;#39; mov byte [gs:0x02],&amp;#39;e&amp;#39; mov byte [gs:0x04],&amp;#39;l&amp;#39; mov byte [gs:0x06],&amp;#39;l&amp;#39; mov byte [gs:0x08],&amp;#39;o&amp;#39; times 510-($-$$) db 0 ; 填充剩下的空间，使生成的二进制代码恰好为512字节 dw 0xaa55 ; 结束标志 以上代码中，我们先设置好参数，然后调用int 10中断，实现了清屏操作。效果如下：
 关于INT 10h的更多细节，可以看这里 wikipedia INT 10h。</description>
    </item>
    
    <item>
      <title>从上电到引导扇区</title>
      <link>https://axiomaster.github.io/post/2021-11-17-os-boot/</link>
      <pubDate>Wed, 17 Nov 2021 21:05:29 +0800</pubDate>
      
      <guid>https://axiomaster.github.io/post/2021-11-17-os-boot/</guid>
      <description>1-1 从上电到引导扇区 1-2 启动补充说明  上电 我们知道，现在使用的计算机都是存储程序计算机（冯·诺依曼计算机）。计算机运行时一边从内存中读取指令，一边执行指令。进一步，可能也知道对于8086 CPU，段寄存器 CS、指令寄存器 IP共同构成的地址[CS:IP]指向当前执行的指令。
但计算机上电开机之后，CS与IP中内容均为空，其它寄存器、内存的内容也为空。类似牛顿力学体系中的第一推动力一样，计算机上电后第一步该如何开始呢？牛顿给的答案是上帝提供了第一推动力。类似的，计算机启动第一步也只能通过体系外的某种方式解决。
上电后执行软件前只能靠硬件。CPU的硬件设计为上电后默认将CS置为0xF000, IP置为0xFFF0，即上电后默认执行的第一条指令位于[CS:IP]=0xFFFF0处的。而这个地址处存储的是BIOS。
BIOS 我们都知道计算机启动后会运行BIOS(basic input output system)，进一步可能也知道BIOS存储在ROM中，当然也知道相对RAM，ROM掉电后信息不会丢失。计算机上电后，硬件将指令地址置为BIOS所在的0xFFFF0处，开始执行BIOS内容。
BIOS会先进行加电自检（POST, Power-On Self-Test），测试各项硬件是否正常等。
加电自检小插曲 我前一阵（2019年底）组装了一台AMD的电脑（AMD, YES!!!）。不考虑打游戏，只用来沉迷于学习，所以预算里没有考虑显卡。等所有零件到了之后迫不及待装好之后上电，然后显示器黑屏，主板上有一个标有VGA的LED红灯常亮。 想了一小会立即意识到，现在Intel的CPU基本都带了核显（大多数人觉得很鸡肋），但AMD的CPU并没有。BIOS加电自检挂这里过不去了。 后来没办法，买了一张二手的GTX960作为亮机卡。  BIOS中断 BIOS还会在内存中起始的4K处0x00000-0x003FF建立中断向量表，以及位于0x0E05B-0x0FFFE处对应的中断服务程序。
BIOS提供的中断服务可以查阅网上资料，参考资料中也提供了一份。我们会用到如下几个：
   中断号 描述     int 10h 显示服务   int 13h 低级磁盘服务   int 19h 加电自检后载入操作系统    调用BIOS中断时，可能需要设置一些参数。比如int 10h中断用来在屏幕上显示信息，就需要指定显示的字符串内容，显示的颜色，位置等信息。中断信息如何设置，BIOS对此都有详细的说明。
加载bootsec BIOS加电自检后使用int 19h中断将软盘中的第一个扇区（512 byte）中的内容复制到内存0x7C00h处，然后开始执行。在Linux中，第1个扇区的内容被称为bootsec。
对于OS来说，我们可以认为计算机加电后直到将bootsec中的内容载入内存并开始执行，这些都是自动完成的，我们只需要关注从bootsec代码开始执行之后的部分就可以了。
bootsec之后的事情我们也可以大致设想一下：依靠bootsec这512个字节的代码，我们会继续读取软盘上更多的代码，然后依赖读入的代码完成更多的工作，直至整个系统运行起来。
一个简单的bootsec样例 CPU硬件设计师，BIOS系统开发等费了九牛二虎之力，终于在上电之后把OS自身最开始的512个字节的bootsec给运行起来了。作为“全村的希望”，当然是希望我们再接再励把OS运行起来的。但这里，我们不管这么多，先写一个hello world再说吧。
org 07c00h ; 告诉编译器程序加载到7c00处 ;----直接往显存中写数据 mov ax, 0xb800 mov gs, ax mov byte [gs:0x00],&amp;#39;h&amp;#39; mov byte [gs:0x02],&amp;#39;e&amp;#39; mov byte [gs:0x04],&amp;#39;l&amp;#39; mov byte [gs:0x06],&amp;#39;l&amp;#39; mov byte [gs:0x08],&amp;#39;o&amp;#39; times 510-($-$$) db 0 ; 填充剩下的空间，使生成的二进制代码恰好为512字节 dw 0xaa55 ; 结束标志  上图中，0xb800是显存开始的地址。显存中，每2个字节对应显示字符，第1个字节为字符对应ASCII码，第2个字节为字符对应的颜色。屏幕每行有80个字符，共24行。这里，我们我们只修改了屏幕左上角开始的前5个字符对应的ASCII码，所以在左上角显示出了hello5个字符。</description>
    </item>
    
    <item>
      <title>GCC Inline ASM</title>
      <link>https://axiomaster.github.io/post/2021-10-31-gcc-inline-asm/</link>
      <pubDate>Sun, 31 Oct 2021 21:05:29 +0800</pubDate>
      
      <guid>https://axiomaster.github.io/post/2021-10-31-gcc-inline-asm/</guid>
      <description>GCC 支持在C/C++代码中嵌入汇编代码，这些汇编代码被称作GCC Inline ASM——GCC内联汇编。这是一个非常有用的功能，有利于我们将一些C/C++语法无法表达指令直接潜入C/C++代码中，另外也允许我们直接写 C/C++代码中使用汇编编写简洁高效的代码。
1.基本内联汇编 GCC中基本的内联汇编非常易懂，我们先来看两个简单的例子：
__asm__(&amp;#34;movl %esp,%eax&amp;#34;); // 看起来很熟悉吧！ 或者是
__asm__(&amp;#34;movl $1,%eax // SYS_exitxor %ebx,%ebxint $0x80&amp;#34;); 或
__asm__(&amp;#34;movl $1,%eax/r/t&amp;#34; /&amp;#34;xor %ebx,%ebx/r/t&amp;#34; /&amp;#34;int $0x80&amp;#34; /); 2.基本内联汇编的格式 __asm__ __volatile__(&amp;#34;Instruction List&amp;#34;); 1、asm __asm__是GCC关键字asm的宏定义：
#define __asm__ asm __asm__或asm用来声明一个内联汇编表达式，所以任何一个内联汇编表达式都是以它开头的，是必不可少的。
2、Instruction List Instruction List是汇编指令序列。它可以是空的，比如：__asm__ __volatile__(&amp;quot;&amp;quot;); 或 __asm__ (&amp;quot;&amp;quot;); 都是完全合法的内联汇编表达式，只不过这两条语句没有什么意义。
但并非所有Instruction List为空的内联汇编表达式都是没有意义的，比如： __asm__ (&amp;quot;&amp;quot;:::&amp;quot;memory&amp;quot;); 就非常有意义，它向GCC声明：“我对内存作了改动”，GCC在编译的时候，会将此因素考虑进去。
我们看一看下面这个例子：
$ cat example1.c int main(int __argc, char* __argv[]) { int* __p = (int*)__argc; (*__p) = 9999; //__asm__(&amp;#34;&amp;#34;:::&amp;#34;memory&amp;#34;); if ((*__p) == 9999) { return 5; } return (*__p); } 在这段代码中，那条内联汇编是被注释掉的。在这条内联汇编之前，内存指针__p所指向的内存被赋值为9999，随即在内联汇编之后，一条if语句判断__p 所指向的内存与9999是否相等。很明显，它们是相等的。GCC在优化编译的时候能够很聪明的发现这一点。我们使用下面的命令行对其进行编译：</description>
    </item>
    
    <item>
      <title>Tensorflow2.0 笔记（2）</title>
      <link>https://axiomaster.github.io/post/2020-09-03-tensorflow2_2/</link>
      <pubDate>Thu, 03 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2020-09-03-tensorflow2_2/</guid>
      <description>六步法  import train, test 网络结构  model=tf.keras.models.Sequential # 搭建网络结构 class MyModel(Model) model = MyModel   model.compile # 配置训练优化器，损失函数 model.fit # 输入特征，batch, epoch model.summary  网络结构 拉直层 tf.keras.layers.Flatten()
全连接层 tf.keras.layers.Dense(神经元个数, activation=&amp;#34;激活函数&amp;#34;, kernel_regularizer=&amp;#34;正则化&amp;#34;)卷积层 tf.keras.layers.Conv2D(filters=卷积核个数, kernel_size=卷积核尺寸, strides=卷积步长, padding=&amp;#34;valid&amp;#34; or &amp;#34;same&amp;#34;)LSTM层 tf.keras.layers.LSTM()
训练方法 model.compile(optimizer=优化器, loss=损失函数, metrics=[&amp;#34;准确率&amp;#34;])Optimizer  sgd adagrad adadelta adam  loss Metrics 训练过程 model.fit(训练集的输入特征, 训练集的标签, batch_size=, epochs=, validation_data=(测试集的输入特征, 测试集的标签), validation_split=从训练集划分多少比例分给测试集, validation_freq=多少次epoch测试一次)</description>
    </item>
    
    <item>
      <title>Tensorflow2.0 笔记（3）</title>
      <link>https://axiomaster.github.io/post/2020-09-07-tensorflow2_3/</link>
      <pubDate>Thu, 03 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2020-09-07-tensorflow2_3/</guid>
      <description>CNN  输入特征图的深度（channel数），决定了当前层卷积核的深度； 当前层卷积核的个数，决定了当前层输出特征图的深度；  tf.keras.layers.Conv2D(kernel_size=卷积核尺寸,strides=滑动补偿,padding=&amp;#34;same&amp;#34; or &amp;#34;valid&amp;#34;,activation=&amp;#34;relu&amp;#34; or &amp;#34;sigmoid&amp;#34; or &amp;#34;tanh&amp;#34; or &amp;#34;softmax&amp;#34;,input_shape=(高, 宽, 通道数))批标准化（Batch Normalization, BN） 池化 池化用于减少特征数据量，最大值池化可提取图片纹理，均值池化可保留背景特征。
舍弃 Dropout 训练时，一定概率随机舍弃神经元。网络使用时，恢复神经元。
卷积神经网络结构 卷积：特征提取器，CBAPD(Convolutinoal, BN, Activation, Pooling, Dropout)</description>
    </item>
    
    <item>
      <title>Weak Reference</title>
      <link>https://axiomaster.github.io/post/2020-03-01-weakreference/</link>
      <pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2020-03-01-weakreference/</guid>
      <description>Weak Reference WeakHashMap </description>
    </item>
    
    <item>
      <title>CameraX</title>
      <link>https://axiomaster.github.io/post/2020-02-17-camerax/</link>
      <pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2020-02-17-camerax/</guid>
      <description>Android CameraX库</description>
    </item>
    
    <item>
      <title>Bazel build system</title>
      <link>https://axiomaster.github.io/post/2020-02-16-bazel-build-system/</link>
      <pubDate>Sun, 16 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2020-02-16-bazel-build-system/</guid>
      <description>这货不支持proxy，也是醉了，这让人咋用啊。</description>
    </item>
    
    <item>
      <title>mediapipe</title>
      <link>https://axiomaster.github.io/post/2020-02-16-mediapipe/</link>
      <pubDate>Sun, 16 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2020-02-16-mediapipe/</guid>
      <description>Google推出的将机器学习/深度学习进行产品化的框架，主要是其中类似tensorflow中图编辑模式。但我们只是看中了人家训练好的手部跟踪的demo。
使用bazel编译系统，但bazel这坑货又不支持proxy。那就需要搞明白所有的编译规则，然后把包挨个离线下下来，然后使用local_repo的方式进行编译。</description>
    </item>
    
    <item>
      <title>x86寄存器汇总</title>
      <link>https://axiomaster.github.io/post/2020-02-01-x86-register/</link>
      <pubDate>Sat, 01 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2020-02-01-x86-register/</guid>
      <description>x86寄存器分类 8个通用寄存器 均为32位。
  EAX
累加寄存器(Accumulator Register)。
  EBX
基地址寄存器(Base Register)。
  ECX
计数寄存器(Count Register)。
  EDX
数据寄存器(Data Register)。
  ESI
  EDI
源/目标索引寄存器(Source/Destination Index Register)
  ESP
基指针寄存器(Base Pointer Register)
  EBP
堆栈指针寄存器(Stack Pointer Register)
  6个段寄存器 段寄存器均为16位。
  CS
指向代码段的段选择符，与EIP寄存器联合构成指令地址。
  DS
  ES
  FS
  GS
指向数据段。
  SS
指向栈段的段选择符。
  5个控制寄存器 均为32位。</description>
    </item>
    
    <item>
      <title>系统启动分析(一)</title>
      <link>https://axiomaster.github.io/post/2020-01-27-post-to-bootsec/</link>
      <pubDate>Mon, 27 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2020-01-27-post-to-bootsec/</guid>
      <description>dumpsys dumpsys input 获取linux事件 getevent -lr </description>
    </item>
    
    <item>
      <title>Android调试</title>
      <link>https://axiomaster.github.io/post/2020-01-10-android-debug/</link>
      <pubDate>Fri, 10 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2020-01-10-android-debug/</guid>
      <description>dumpsys dumpsys input 获取linux事件 getevent -lr </description>
    </item>
    
    <item>
      <title>activity、window、view和surface</title>
      <link>https://axiomaster.github.io/post/2020-01-09-activity/</link>
      <pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2020-01-09-activity/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Android启动分析</title>
      <link>https://axiomaster.github.io/post/2020-01-07-zygote/</link>
      <pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2020-01-07-zygote/</guid>
      <description></description>
    </item>
    
    <item>
      <title>aosp源码编译与阅读</title>
      <link>https://axiomaster.github.io/post/2020-01-07-aosp/</link>
      <pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2020-01-07-aosp/</guid>
      <description>下载源码 国内从google下载aosp源码需要翻墙，很不方便。可以使用清华大学开源软件镜像站提供的镜像地址进行下载,同步代码.
下载,检出代码按照清华镜像站的地址说明一步步操作就可以了.
可能的错误  初始化包比较大,下载后记得进行md5校验. 使用迅雷中断后续传,发现md5值不匹配,推荐使用uget之类的工具在晚上下载,一次成功.  aosp编译 官方指导
 建立编译环境 编译 Android  编译很简单, aosp源码中prebuilts目录下集成了所有编译会用到的工具,包括clang, jdk等,不需要额外下载. 编译脚本只支持python2,环境上安装一下python2就可以了.
在Ubuntu 18.04上使用如下步骤进行编译:
设置环境变量等 source build/envsetup.sh 设置编译目标版本 lism@lism-u18:~/android/aosp$ lunch aosp_x86_64-eng ============================================ PLATFORM_VERSION_CODENAME=R PLATFORM_VERSION=R TARGET_PRODUCT=aosp_x86_64 TARGET_BUILD_VARIANT=eng TARGET_BUILD_TYPE=release TARGET_ARCH=x86_64 TARGET_ARCH_VARIANT=x86_64 TARGET_2ND_ARCH=x86 TARGET_2ND_ARCH_VARIANT=x86_64 HOST_ARCH=x86_64 HOST_2ND_ARCH=x86 HOST_OS=linux HOST_OS_EXTRA=Linux-5.0.0-37-generic-x86_64-Ubuntu-18.04.3-LTS HOST_CROSS_OS=windows HOST_CROSS_ARCH=x86 HOST_CROSS_2ND_ARCH=x86_64 HOST_BUILD_TYPE=release BUILD_ID=QD1A.190821.011 OUT_DIR=out ============================================ 如果不清楚需要输入什么版本, 输入lunch后会自动列出支持的版本信息.
lism@lism-u18:~/android/aosp$ lunch You&amp;#39;re building on Linux Lunch menu... pick a combo: 1. aosp_arm-eng 2. aosp_arm64-eng 3. aosp_blueline-userdebug 4. aosp_bonito-userdebug 5.</description>
    </item>
    
    <item>
      <title>Handler和Looper</title>
      <link>https://axiomaster.github.io/post/2020-01-05-handler/</link>
      <pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2020-01-05-handler/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Handler和Looper</title>
      <link>https://axiomaster.github.io/post/2020-01-05-looper/</link>
      <pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2020-01-05-looper/</guid>
      <description></description>
    </item>
    
    <item>
      <title>I/O模型</title>
      <link>https://axiomaster.github.io/post/2020-01-05-io/</link>
      <pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2020-01-05-io/</guid>
      <description>I/O处理过程 系统调用 操作系统出于安全的考虑，将进程的内存空间划分为用户空间(0~3G)和内核空间(3-4G)。进程在执行用户自己的代码时处于用户态(ring3); 当用户代码需要操作系统资源时, 可以通过调用操作系统提供的标准接口(POSIX)进行访问, 此时进程从用户态切换到内核态. 操作系统提供的这些接口称为系统调用.
使用top命令时, Cpu后面的us就对应用户态使用的cpu, sy就对应内核态使用的cpu.
%Cpu(s): 1.2 us, 0.7 sy, 0.0 ni, 98.0 id, 0.1 wa, 0.0 hi, 0.0 si, 0.0 st 硬盘, 网卡等等这些设备, 用户代码都是无法直接访问的, 需要通过操作系统提供的标准系统调用进行访问. 对于linux系统, 将所有的设备都抽象成文件, 因此, 对于这些设备的访问都可以归类为IO操作.
文件读取过程 用户程序读取磁盘或网卡上的数据, 执行read系统调用时可以分为2个过程:
  操作系统需要将磁盘或网卡上的数据先拷贝到内核缓冲区
  操作系统再将内核缓冲区的数据拷贝到用户缓冲区
  内核缓冲区 我们知道, 硬盘等外设因为硬件原因, 读写相对内存来说是要慢几个数量级的. 如果内核一有数据就立即写入磁盘, 就需要频繁的调用驱动的硬件.操作系统为了提高与硬件交互的效率, 并不会一有数据就立即写入, 而是等攒够一些数据之后再批量写入.
因此, 内核缓冲区时为了减少内核与外部硬件交互的次数.
用户缓冲区 操作系统进行系统调用是有一定开销的, 而且相对开销很大. 回想读取文件时, 我们都会先申请一个buffer数组, 然后循环每次read len大小的数据, 之后代码对buffer内容进行处理.
这么做的原因是为了避免频繁的进行系统调用. 关于len为什么取1024或4096, &amp;laquo;UNIX环境高级编程&amp;raquo;中专门有讨论, 这个取值是基于统计分析出来的最佳大小.
因此, 用户缓冲区是为了减少系统调用次数.</description>
    </item>
    
    <item>
      <title>自己动手组装台式机</title>
      <link>https://axiomaster.github.io/post/2019-12-31-makeup-computer/</link>
      <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-12-31-makeup-computer/</guid>
      <description>双十一买了一个34&#39;的21:9超宽屏显示器，回来之后接上笔记本，越来越觉得笔记本有点儿带不动。正好最近学习android需要编译aosp， 然后就研究了一下攒机，预算3000，组一台linux编译机。于是趁着双十二买了一堆零件自己组了一台电脑。
配置单 先说说最终的配置：
   配件 型号 价格     CPU ryzen 3700x    主板 MSI B450M mortar max 主板+CPU套装 ￥2514   内存 海盗船 DDR4 3600MHz 16G x 2 ￥1038   固态硬盘 阿斯加特 M.2 NVMe 500G ￥343   显卡 二手铭暄 GTX 960 2G ￥399   电源 酷冷至尊 MWE 550 铜牌 ￥312   机箱 先马 征途 中塔机箱 送5把RGB机箱风扇 ￥164   显示器 小米 34&amp;rsquo; 曲面显示器 ￥1999   无线网卡 腾达U10 USB无线网卡 ￥59   dp线 绿联 DP 1.</description>
    </item>
    
    <item>
      <title>Making debugger for Golang</title>
      <link>https://axiomaster.github.io/post/2019-08-11-debugger-golang/</link>
      <pubDate>Sun, 11 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-08-11-debugger-golang/</guid>
      <description>转载自 Making debugger for Golang (part I)
 The goal of this series is not to write full-featured debugger for Go programming language. If you’re looking for some then please take a look at Delve. We’ll try to understand here how debuggers work in general and how to implement basic one on Linux which takes into account Golang’s features like goroutines.
Creating debugger isn’t easy though. We won’t even strive to cover this topic within a single story.</description>
    </item>
    
    <item>
      <title>Making debugger for Golang</title>
      <link>https://axiomaster.github.io/post/2019-08-11-debugger-golang2/</link>
      <pubDate>Sun, 11 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-08-11-debugger-golang2/</guid>
      <description>转载自 Making debugger for Golang (part II)
 During the first part we’ve bootstrapped development environment and made a simple program (tracer) which stops child process (tracee) at the very beginning and then continues it execution together with showing its standard output. Now it’s time to extend its basic capabilities.
Usually debuggers allow to single-step through debugged program. It can be done using ptrace PTRACE_SINGLESTEP request which tells tracee to stop after execution of single instruction:</description>
    </item>
    
    <item>
      <title>Making debugger for Golang</title>
      <link>https://axiomaster.github.io/post/2019-08-11-debugger-golang3/</link>
      <pubDate>Sun, 11 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-08-11-debugger-golang3/</guid>
      <description>转载自 Making debugger for Golang (part III)
 So far we’ve learned how to single-step ptraced process (tracee) and get some debugging info out of binary (read it here if you haven’t done it yet). Now it’s time to set a breakpoint at desired place, wait until reached and then investigate process state.
Let’s start with assembly code used before:
section .data msg db &amp;quot;hello, world!&amp;quot;, 0xA len equ $ - msg section .</description>
    </item>
    
    <item>
      <title>神奇的bug</title>
      <link>https://axiomaster.github.io/post/2019-07-30-bug/</link>
      <pubDate>Tue, 30 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-07-30-bug/</guid>
      <description>最近在编译一个node相关的工程，配置好编译环境，设置好代理，昨天一切都进展的挺顺利，很快就得到了结果。但后来发现编译的版本稍微有点儿差异，校验不通过。就把源码切到特定的tag上重来一次。然后就发现了一个神奇的bug。
使用yarn编译，中间一步依赖的一个包在编译时需要去api.github.com上下载特定版本的软件包。但是目标版本使用的软件包版本号类似于v1.2.3-2，在小版本号之后还有-2进行区分，然后这个软件包总是下载失败，导致编译失败。
验证了好久之后确认，代理设置没有问题，其它依赖包可以下载成功，但这个就是不行。后来在issue列表中确认，在特定proxy环境下，这个包会下载失败。失败原因是node中下载使用的request包在经过部分proxy时，对-这样的字符无法正确处理，url错误导致下载失败。
而且搜索后发现这个问题很普遍，不只是vscode的issue列表中报过多，其他很多使用node的开源软件都报过。而且因为是request的问题，一般的解决方法就是回退或更新第3方依赖的软件包，确保软件包的url中不包含-这样的版本号。</description>
    </item>
    
    <item>
      <title>docker私有镜像仓库</title>
      <link>https://axiomaster.github.io/post/2019-06-24-docker-registry/</link>
      <pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-06-24-docker-registry/</guid>
      <description>上一篇VS code remote提到国内访问docker官方镜像特别慢，可以使用加速器。但对于企业等，都会自建私有镜像地址，也可以解决这个问题。
docker registry  Registry是一个无状态的，高可扩展的服务端应用，主要用于存储和分发Docker镜像。
Docker Registry文档
 下载registry镜像 1 直接运行registry
这种方式需要机器能够访问docker.io
docker run -d -p 5000:5000 --name registry registry:2 2 保存registry.tar并运行
  通过可以访问外网的机器先 docker pull registry放入本地镜像仓库
  使用docker save保存为tar包
  将registry.tar拷贝到无法访问外网的机器上
  使用docker load -i将tar包加载到本地镜像仓库
  最后docker run运行registry服务
  配置私有镜像地址 1 将镜像docker push至私有镜像仓库
和使用registry.tar运行registry服务类似，思路如下：
  将镜像tar包拷贝到机器上
  使用docker load -i加载到本地镜像
  使用docker tag为镜像打上私有镜像地址的标签，比如192.168.1.11:5000/ubuntu:least
  使用docker push将镜像推到镜像仓库
  使用私有镜像地址 修改daemon.</description>
    </item>
    
    <item>
      <title>Don&#39;t be evil</title>
      <link>https://axiomaster.github.io/post/2019-06-15-dont-be-evil/</link>
      <pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-06-15-dont-be-evil/</guid>
      <description>上周和一个久未见面的朋友聊天，后来发现聊天的大部分内容都是吐槽工作。晚上又失眠了，脑袋里全是最近上班的事，吐槽一波~
一、问题指责定界
这两天问题攻关（版本release前消灭问题单），我负责的Java通信框架部分很有意思，14张单下来没改一行代码。对面人说看你最近打电话多了很多，一直在扯皮。其中有几个问题很有代表性。
1 业务失败了，定位邮件转了一圈之后发现a服务调用b服务，a未收到响应。a截图发邮件给另一个部门的b，b回截图显示a调用发起1min左右响应了。a自己分析发现调用走Nginx，默认断链时间30s。但是a因其它原因配置了全局6min的超时时间，并未超时失败。 有意思的是a组大佬回复，框架定位响应1min问题，然后框架定位超时吃一单。 很老的问题单，日志早丢了（吐槽日志系统）。拉了一圈人电话了解业务情况，还原场景。问到a大佬时原话：“背景我也不了解，我看问题没人跟了，就让框架看一下”。 release点前都不愿接单，开始扯皮上升。再升一级se，说有2个问题，通信1min问题和失败问题bulabul&amp;hellip;&amp;hellip;
可是大哥，分布式系统里请求时长都是基于0.5/0.99分度只有统计意义的，你让我定位单次请求1min的问题，而且还是一个被各种开发，各种可靠性测试蹂躏的一个测试环境，wtf。而且问题已经很明确，1min请求时长正好暴露了a的接口容错机制明显有问题，不论是改超时时间，还是去改Nginx时长，或者接口同步机制&amp;hellip;&amp;hellip; 扯到最后，多谢a的大佬和se怜悯我们300多缺陷单，同时新版本a接口已下线，同意接单。 吐槽一下我们测试问题定界机制，问题邮件发出来之后启动24h超时定时器，击鼓传花一样最后落在谁手里谁吃单。定位期间测试也不关注定位逻辑是否合理，很多不需要业务背景，只要前后语义分析就能发现有明显逻辑漏洞的定位结论直接就回复了。这就导致定位倾向于找一个任意异常日志贴上去然后转给下一跳，反正下一跳也不知道我业务是什么。系统里的失败必然伴随着服务间调用失败，框架就很吃亏。接口人跟我诉苦，自己调休一天，30多个定位邮件&amp;hellip;&amp;hellip;上班还要各种会议挂着，也难怪会超时提单了。
2 业务失败，定位进展为f服务的sdk调用f服务，调用抛异常了，没有完整日志只有异常截图，而且多次出现。找到f，人很赞，业务背景有问必答，最后还很nice的提示我f服务使用了自定义lb策略，可能是这里的问题。 我就下sdk代码，背景服务d代码，f服务端代码，看了半天发现。咦，根据日志抛出的异常推断这只能是你们自己实现的自定义lb选路失败了导致的。只是框架定义了lb接口以及lb异常机制，所以异常栈里全是框架信息。 f很爽快，定位清楚后就接单了。不过他们也很痛苦，自定义lb里都没有打日志&amp;hellip;&amp;hellip;
类似上面，邮件内容为yb看一下为啥异常，然后超时提单。
3 m内存超规格了，m接口人没有看内存信息，而是从日志里翻出来调我们g失败了。一个资源问题就神奇的转变为调用g失败的问题了，性能测试也很神奇的认可了这个结论。 可是我们可靠性se可是说，a依赖b，b挂掉后a是要惯性运行的啊。m好不惯性啊！ 然后就开始了漫长的扯皮，最后m撂下话，单肯定是不能接的，最多只同意复制一张，各自管各自的问题。
哎，提单是测试的绩效。可是好多单提出后就没有焦点了，想要跟踪的问题也说不清楚。问题不分主次，一打一大片。
二、跨组驱动
我们搞了一个特性，需要别人适配。当时开发好急哦（好像所有特性都这样），5月31号发出来催别人赶紧适配，要赶7号版本。后来赶不上了，再赶15号最终版本。群里说，邮件推，但其他组都没动静。等到14号测试介入要提单了所有人都慌了。一下午我电话被打爆了。 所有人都有怨言。原来我之前已经在4月多搞了一个止血方案，5月初又搞了一个针对Java的方案，现在我搞得是全语言版的最终方案，以前的都是临时方案。 2周前适配发了邮件，但没有用需求推动。小组长只管需求列表，问题单列表，其他组一个小开发的适配邮件谁鸟你，所以看不见。不得不说还是测试牛逼，说要提单所有人都紧张了。 大家跑来吐槽我为啥这时间点发适配，为啥这么频繁的改适配方案，我很懵逼，很慌。同是开发，同在消单，相煎何急。 自己想一下，很内疚。驱动别人去适配，别人也算客户吧。以客户为中心难道忘了吗？为啥方案变更这么频繁，客户体验太差了吧！驱动不好，时间点卡的这么赶，简直是在犯罪啊。毕竟兄弟们都已经两班倒，24h在岗了。
以前我不太懂dont be evil是啥意思，我们不应该是be kind，be nice，be cool吗？现在想想，工作中能做到dont be evil就很不错了，很多时候不自觉的就对外作恶了。
包括不限于不在代码中留下一坨屎。昨天我们组的女前辈在群里发了一张屎一样的代码截图，最后git记录显示是我合入的。但是我很肯定这代码不是我写的，大致背景我也记得，但git记录没法辩驳，而且我提交时确实没看内容。
工作前就是刷leetcode之类，只关注是否work。说实话软件工程能力或者说对好代码的辨别力，如何写出好代码的能力很缺失。细节处有很多盲区。 入行也2年了，期间被那位女前辈，还有其他前辈像上面那样吊打，多次按在地上摩擦。 被别人指正String类型的不可变性是源自内部实现的final char[]；for循环的作用域区间是整个循环过程而非单次循环&amp;hellip;&amp;hellip; 认识到错误时都很感激，自己很惶恐，也在反思，总结哪种好，哪种不好，提升自己对细节的把控和品鉴力。
但也发现很多代码更糟糕，很多问题定位太随意，一些事情像上面适配那样的驱动方式太简单粗暴，一些低效内耗行为明显与有效产出方向不一致，更遑论一些宣称很有价值，很nice，很cool的事情深入之后发现是豆腐渣，没有任何意义&amp;hellip;&amp;hellip;
能说什么呢，天也亮了，希望工作生活中大家都能dont be evil，把自己这一跳的事情努力尽责做好，提升自己能力，之后再说be kind，be nice，be cool吧~</description>
    </item>
    
    <item>
      <title>Java并发编程</title>
      <link>https://axiomaster.github.io/post/2019-04-27-java-concurrent/</link>
      <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-04-27-java-concurrent/</guid>
      <description>缓存一致性与并发问题 我们今天使用的计算机体系结构都属于存储程序型（冯·诺伊曼结构），运行时所有的数据都存储在内存中；指令执行时，数据从内存读入寄存器，运算结束后再写回内存。
// i == 0 i = i + 1 // i == 1 以上面代码为例，计算机先将i加载到寄存器中，再寄存器中+1后再将i写回内存。
可以认为运算中，寄存器中的数据是内存的一份缓存。但是，有缓存，就有缓存不一致的问题。
我们只考虑多CPU时的并发问题。单线程执行时，以上执行顺序不存在问题；但并发场景下，假设2个线程A、B同时执行，A读入寄存器的值均为0, 计算后都为1，在A写入内存前，B此时读取到的值为0，最终写入内存的i为1，显然存在问题。
解决缓存不一致问题，通常有2种方法：
 在总线加锁； 使用缓存一致性协议；  总线加锁 CPU通过总线读取内存，通过在总线加锁，锁未释放前，CPU只能再次读取i所在内存，直到锁释放。早期CPU采用这种方式，这样可以解决不一致问题，但这等于同一块内存锁释放前无法访问。
缓存一致性协议 Intel的MESI协议，提供了如下机制：CPU写数据时，如果发现变量是共享变量，会发信号通知其它CPU将该变量的缓存置为无效状态。其它CPU操作时发现缓存失效了，就会重新从内存读取。
并发编程中的概念 原子性 提到原子性时都会以银行转账为例：用户A向用户B转账100元。
转账事务请求中，银行会进行2项操作：A账户减少100元；B账户增加100元。
不管银行按什么顺序执行，如果2项操作进行到一半时失败了，银行都需要先进行回滚，否则就会出现错误（银行损失或用户A损失）。
换句话说，银行需要保障转账的原子性：这项请求要么成功，要么失败，不能出现任何中间状态（2个操作一个成功，一个失败）。
对应到计算机运行中，一些操作是原子性的，另一些操作是由若干原子性操作组合而成。
比如根据上面分析，i=i+1不是原子操作；那i=9是原子操作吗？如果计算机分别对i的高低16位先后赋值，那就不是原子操作。
可见性 可见性是指多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
比如：
// 线程A int i = 0 i = 5 // 线程B j = i 如果线程A执行完i = 5但尚未写入内存时，线程B从内存看到的i = 0，无法看到线程A缓存中i的值已经发生变化。
有序性 以下代码示例来自《七周七并发》
public class Puzzle { static boolean answerReady = false; static int answer = 0; static Thread t1 = new Thread() { @Override public void run() { answer = 42; answerReady = true; } }; static Thread t2 = new Thread() { @Override public void run() { if (answerReady) { System.</description>
    </item>
    
    <item>
      <title>Golang defer导致内存溢出</title>
      <link>https://axiomaster.github.io/post/2019-04-14-defer/</link>
      <pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-04-14-defer/</guid>
      <description>Golang中提供了defer关键字，以前可能需要在函数内进行多次判断之后释放资源，现在使用defer一次就搞定了，习惯之后会觉得这个特性非常好用。
问题代码 有一句话是软件设计没有银弹，放在这里依然成立。defer这么好用，但也需要注意一些坑。代码逻辑大致如下：
for { defer 释放资源 // http request  // 错误码判断  // sleep 5s重试 或 break退出 } 业务是心跳这样的守护进程，所以直接就用了死循环，请求失败之后进行重试，或满足一定条件时退出循环。使用defer在最后释放资源。
测试时异常场景也进行了覆盖，功能上没有发现问题。但在一个实例上发现运行一段时间之后内存爆了。
问题分析 defer的实现机制是在调用函数栈上再压入defer函数，调用return前调用defer函数。所以调用defer会有一次压栈操作。
上面的示例中将defer在for循环中，环境恰好没有返回对应的错误码让for循环退出，导致defer一直被执行，重复的压栈导致StackOverflow。
小结 从这里看，将defer放入循环中就是一个不好的习惯；另外，死循环代码也有一丝丝坏味道，看到这样的代码时就应该警惕了。</description>
    </item>
    
    <item>
      <title>一道数学题</title>
      <link>https://axiomaster.github.io/post/2019-03-22-simple/</link>
      <pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-03-22-simple/</guid>
      <description>我女朋友从中学时数学就不咋样，高中时理科太差就只能读文科，读了文科数学依然最差。大学数学还需要补考才能毕业，考研时因为不考数学才读的现在的专业。我略好一些，高中时借着给她补习数学才走到一起。
这是背景。
前一阵子和女朋友去买鞋，商场满减，400减100，700减200，900减300。我们选中了一双700多一点儿的鞋，刚好凑够满减。付钱的时候，收银台有个大姐，选了一条裤子200多，要和我们一起凑单。
我想都没想就说可以啊。这时候我女朋友突然问，那怎么凑？她这么突兀的一问，我还没反应过来。大姐也呆住了，就说你们减200，我们减100啊。我女朋友就有点儿吞吞吐吐了，我们已经够减200了之类的。大姐见势不妙，就让一步说那你们减220，自己减80。听到这里我都有点儿不好意思了，刚好收银员也扫好了码催付款。我赶紧付了钱，收了大姐的余额就往出走。大姐的丈夫过来后了解清楚了，就在背后说互利互惠什么的。
走出门的时候，我总觉得自己占了人家20块钱的便宜，心理有点儿内疚。我女朋友却说，她本想着我们减250，他们减50。看我一脸震惊，就跟我开始算起了帐。我们700多，不需要他们也能优惠200；他们没我们，啥优惠也没有；加一起之后，多优惠了100，那这100按比例我们应该70，他们30，至少也得平分。
至此我才突然转过弯儿来，从头至尾我不仅没占人家便宜，还被别人占了便宜。</description>
    </item>
    
    <item>
      <title>使用Gradle开发IDEA插件</title>
      <link>https://axiomaster.github.io/post/2019-04-21-gradle-proxy/</link>
      <pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-04-21-gradle-proxy/</guid>
      <description>最近想试着开发一个IDEA的插件，官方指导 中有两种方式:
 使用Gradle 使用DevKit  而且官方推荐Gradle的方式，称DevKit的工作流已经过时了。但百度出来的全都是DevKit的方式。而且Android Studio也是gradle，那就试试gradle的方式开发一个插件。
Gradle配置 使用gradle创建工程之后，需要下载一些文件，因为GWF的原因这一步会特别慢，不使用VPN基本都失败了。网上找了使用aliyun源的方式，搞定了这一步。
单个工程修改 将工程下build.gradle中的repositories替换为如下内容
repositories { maven { url &amp;#39;https://maven.aliyun.com/repository/public/&amp;#39; } maven { url &amp;#39;https://maven.aliyun.com/repository/google/&amp;#39; } maven { url &amp;#39;https://maven.aliyun.com/repository/jcenter&amp;#39; } } 具体替换地址可以看aliyun官网的地址，网上大多数配置都没有更新，使用的还是旧地址。
全局配置 以上方式只修改单个工程的，每次新建工程都要修改，很麻烦。下面这个方法可以修改全局的配置。
在 C:\Users\用户名\.gradle目录下创建init.gradle文件，内容如下：
allprojects { repositories { maven { url &amp;#39;https://maven.aliyun.com/repository/public/&amp;#39; } maven { url &amp;#39;https://maven.aliyun.com/repository/google/&amp;#39; } maven { url &amp;#39;https://maven.aliyun.com/repository/jcenter&amp;#39; } all { ArtifactRepository repo -&amp;gt; if (repo instanceof MavenArtifactRepository) { def url = repo.url.toString() if (url.startsWith(&amp;#39;https://repo.maven.apache.org/maven2/&amp;#39;) || url.</description>
    </item>
    
    <item>
      <title>工厂模式 Factory Pattern</title>
      <link>https://axiomaster.github.io/post/2019-03-31-factory-pattern/</link>
      <pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-03-31-factory-pattern/</guid>
      <description>工厂模式定义了一个创建对象的接口，但由子类决定要实例化的类时哪一个。工厂方法让类把实例化推迟到子类。
 简单工厂 简单工厂的思路也确实非常简单，就像将创建类的代码进行了简单的抽离。《设计模式》也说这不应该算一种模式，更像一种编程习惯。就好比撸完代码之后自己回头看看，发现这一块独立的逻辑可以抽离出来独立一下。
 工厂模式 工厂模式中，创建者与产品为平行类层级，只是创建者的创建方法产生产品。要创建哪种产品，由具体的创建者子类决定；产品的实际创建，也由产品的具体实现类完成。
 代码 略</description>
    </item>
    
    <item>
      <title>状态模式 State Pattern</title>
      <link>https://axiomaster.github.io/post/2019-03-17-state-pattern/</link>
      <pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-03-17-state-pattern/</guid>
      <description>状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
 工作中经常会遇到各种状态机，使用流程控制的方式虽然也可以实现，但后续的维护变动就变得很困难。在实际中我们现在就遇到了一个这样子的问题，整个状态机的代码有一千多行，代码完成的还算工整，但要看懂现在就只能对比状态图了，因为状态实在太多了。我曾经增改过两次，每次改动都伴随着一大堆的问题单。
这时候就真真切切体会到状态模式的好处了。
类图  状态模式 vs 策略模式 如果与策略模式的类图对比的话，会发现图结构几乎一模一样。虽然如此，这俩模式还是有比较明显的区别。
策略模式中，最后的每一个业务类只包含了一组算法中的一个实现；或者说每一种算法的组合形成了一个业务类。
但在状态模式中，业务类中继承了算法的所有实现，并且在运行态切换算法为不同的实现，从而让自己拥有不同的行为（表现为不同的状态）。
我觉得类比之前策略模式中不同种类鸭子的实现，状态模式只存在一只百变鸭，但这只鸭子根据外界输入一会将自己变成红头鸭吱吱叫，一会儿变成绿头鸭呱呱叫。
代码 略</description>
    </item>
    
    <item>
      <title>神奇的bug</title>
      <link>https://axiomaster.github.io/post/2019-03-23-bugs/</link>
      <pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-03-23-bugs/</guid>
      <description> 状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
   Etcd启动失败
  数字排序问题
  golang defer导致内存溢出
  jpa事务读写
  CRL校验问题
  </description>
    </item>
    
    <item>
      <title>静态库与动态库</title>
      <link>https://axiomaster.github.io/post/2019-04-27-dlib/</link>
      <pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-04-27-dlib/</guid>
      <description>编译流程  编译生成可重定位目标文件，经链接器将其和依赖的库组合起来，生成可执行文件。
可执行文件运行时，经过加载器(loader)将其中的代码和和数据拷贝到内存，然后跳转到程序起始地址开始执行。
 链接 连接器主要完成2个任务
 符号解析：每个符号对应一个函数，全局变量或静态变量。符号解析将符号引用与符号定义关联起来。 重定位：编译器生成的可重定位目标文件中地址从0开始。链接器把多个库合并，将符号与内存地址关联，重定位这些节，并修改符号引用地址。  ELF文件  可执行可链接格式ELF(Executable and Linkable Format)
   静态库与静态链接 linux上静态库以存档（archive, .a后缀）文件格式存储，是一组可重定位目标文件的集合。
静态链接时，会将.a中对应的内容拷贝，最终生成的可执行文件中包含静态库内容。程序运行时不再依赖静态库。
动态共享库与动态链接  静态库内容需要拷贝到可执行文件中，生成目标文件比较大，占用空间（减少了运行时依赖，现在看也许是优势） 静态库不支持热更新  相比静态库，以上就是动态库的特点：允许多个进程在内存中共享同一份库代码。
位置无关代码  位置无关代码PIC(Position-Independent Code), 编译时需要指定-fpic参数
 显示调用 显示使用共享库时不需要依赖头文件，通过dlfcn.h中提供的API进行调用：
// 将动态库加载到内存 // 指定名称，在LD_LIBRARY_PATH、/lib、/usr/lib目录下查找 // 或指定全路径 void *dlopen(const char *libname,int flag); // 在动态库中查找对应函数 void *dlsym(void *handle,const char *symbol); // dlclose() // 获取最近一次error信息，调用后会清空最近的错误信息 char *dlerror(void); 显示调用，可以在运行时打开库函数进行调用，有点儿类似动态语言的效果；而且，在代码执行到dlopen之前，so可以不存在。
隐式调用 隐式调用时需要引用库对应的头文件，代码中直接调用头文件中声明的函数即可；编译时，通过-l指定需要链接的库。
但隐式调用，在可执行文件开始执行时，所有依赖的库必须存在，否则无法运行。
后记 又水一篇。
链接中ELF结构与《深入理解Java虚拟机》第6章 类文件结构简直神似，看这种内容就和看模电或高频里一大坨电路图一样，全是记都记不住的细节。果然还是脑袋缓存太小了，处理太慢了。</description>
    </item>
    
    <item>
      <title>工具篇</title>
      <link>https://axiomaster.github.io/post/2019-03-03-plantuml/</link>
      <pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-03-03-plantuml/</guid>
      <description>曾经信心满满的立过很多flag，要学习并掌握某一领域或坚持某件事儿，最终都无疾而终，只剩下零星概念和一堆遗憾，原因大都类似：
 计划被其它事情打断，中止了 进行到一半，发现意义不大 进行中遇到了困难，放弃了 当时掌握了，但没有及时总结，后续没有练习，忘记了  包括不限于协议栈、数据库、JVM、正则表达式、音律、写总结&amp;hellip;&amp;hellip;也包括设计模式。结果一回头，猛然发现时间已经过去了这么久，却什么都没有留下来。
在此再立一个flag，每周写一篇总结。周积跬步，以致千里。
UML  统一建模语言 (Unified Modeling Language, UML)
 所有介绍设计模式的资料都会用到uml图。之前总以为UML图就是类图，每次都是被继承，实现里面的实线、虚线、箭头等给整懵了。然后就放弃看图，只看代码实现。
现在才知道，类图只是UML中的一小部分。UML图还包括用例图，时序图等。和SE等大佬交流时，设计文档里全是各种UML图。
PlantUML 各种工具都可以画UML图，包括visio，Visual Paradigm等。我们使用PlantUML, 像Markdown一样，通过简单的语句写UML图，使用方便。当然，这一套工具也都是免费的。
windows安装  PlantUML  PlantUML有IntelliJ IDEA的插件版，可以直接在IDEA的plugins中下载安装。我们也使用这个版本。
 插件装好之后，新建puml文件，直接打开就可以看到对应的编辑器了。
  Graphviz  安装插件之后，也可能无法看到右边的预览图，而是提示报错，这是因为缺少Graphviz环境变量。Graphviz是一个开源的绘图软件，很多开源软件生成可视化图时都使用Graphviz。
下载Graphviz并安装后，配置如下环境变量之后就好了。
GRAPHVIZ_DOT=D:\Program Files (x86)\Graphviz2.38\bin\dot.exe PlantUML基本语法  PlantUML类图
  泛化，Generalization 关联，Association 组合，Composition 聚合，Aggregation 实现，Realization 依赖，Dependency  @startuml Class01 &amp;lt;|-- Class02:泛化 Class03 &amp;lt;-- Class04:关联 Class05 *-- Class06:组合 Class07 o-- Class08:聚合 Class09 &amp;lt;|.. Class10:实现 Class11 &amp;lt;.. Class12:依赖 @enduml   </description>
    </item>
    
    <item>
      <title>策略模式 Strategy Pattern</title>
      <link>https://axiomaster.github.io/post/2019-03-05-strategy-pattern/</link>
      <pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-03-05-strategy-pattern/</guid>
      <description>策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。
 类图  继承 vs 组合 上面的描述有些抽象。策略模式想要表达的是，如果一个类需要某种行为，不要通过继承来实现（is-a），可以使用组合（has-a）来实现。这样做更加灵活，当业务类（duck）的行为（fly）需要改变时，只需要注入不同的算法实现类即可。
这也就是 鸭子继承， 如果一个类通过组合获取了鸭子的行为，那它就可以当作鸭子使用，不需要关注它是否继承自鸭子基类，是否真正的是一只鸭子。
Java中Spring的依赖注入（DI）也是这种思路。Golang中甚至取消了继承，从语法层面避免继承所带来的耦合。这里甚至可以推测，OOP在提出之初，只是基于对真实世界中对象建模的思路，提出了继承，实现等概念。但后续工程实践发现继承并没有组合好用。
很多协议设计也是这样，基于最初的构想设计了很多特性，结果后续使用中发现一部分设计很鸡肋或很容易出错。于是又通过各种约定，最佳实践，框架等来解决这些问题。
代码 public interface FlyBehavior { void fly(); } class FlyWithWings implements FlyBehavior { @Override public void fly() { // todo  } } class FlyNoWay implements FlyBehavior { @Override public void fly() { // do nothing  } } public interface QuackBehavior { void quack(); } class Quack implements QuackBehavior { @Override public void quack() { // todo  } } class Squeak implements QuackBehavior { @Override public void quack() { // todo  } } class MuteQuack implements QuackBehavior { @Override public void quack() { // todo  } } public abstract class Duck { FlyBehavior flyBehavior; QuackBehavior quackBehavior; abstract void display(); void performFly() { flyBehavior.</description>
    </item>
    
    <item>
      <title>程序员的浪漫</title>
      <link>https://axiomaster.github.io/post/2019-02-27-programer-romantic/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-02-27-programer-romantic/</guid>
      <description>程序员的浪漫 之前学习TLS时向一个做安全的朋友请教，过程中他给我讲了下面一个故事。听完后甚是感动，分享给大家。
为了方便描述，以我朋友的视角进行描述。
背景 公司开发的产品涉及安全时都要求使用TLS通信，TLS通信时需要使用证书。申请证书时需要预先制作好私钥，私钥与证书里的公钥形成密钥对。非对称加密可以粗略的理解为，通信前将你的证书发给对端，对端使用你证书中的公钥进行加密。加密后的密文只有对应的私钥才可以解密。只要私钥不泄密，就可以保证安全。
 但通信时是需要使用私钥进行解密的，所以私钥也需要存储在服务器上。如果服务器被攻破，私钥被窃取，这样也很危险。所以使用openssl制作私钥时一般都要求提供一个密码来保护私钥。一般支持TLS的工具都支持加载加密后的私钥和密码来进行通信。
但是密码也是需要存储的，密码泄露也存在安全风险。更近一步的方法就是使用对称加密将私钥密码也进行加密，解密只能使用特定的工具进行。工具被编译成二进制文件，解密直接在内存进行，解密后的密码和私钥不存储，直接使用。
私钥 希望看完上面一段背景之后你还没有晕。
从上面我们可以看出，实际使用中一般开发人员是没机会接触到私钥密码的，大家直接使用加密后的私钥和密码就可以了。实际中也是这样。产品开发中都使用预置的证书、私钥，交付后由客户替换为商用证书就可以了。开发人员也不会关注预置证书是哪里来的，怎么生成的。
一次我们启动新项目，特殊原因要求我们更新一份新的证书。但替换后出了岔子，小部分业务无法相互通信，我被要求定位清楚问题出在哪里。为了确认是证书误用还是业务处理的问题，我需要把加密后的私钥解密，然后和公钥校验。折腾了小半天，拿到校验结果之后，我终于说服其他开发是他们的业务处理的问题。这个问题也就结束了。
私钥密码 解密私钥时，我需要先把私钥密码解密出来。搞定了问题之后，我又回想起那个私钥密码。那个密码很特殊，明显是人名全拼+数字组成的，这激起了我的好奇心。我本以为这数字是一个工号，查了一下并没有，难道已经离职了？又查了一下人名全拼，这次倒是查到了几位，挨个看了之后感觉都不太可能。
这时我的八卦之魂已经熊熊燃烧，停不下来了。那就最简单的方法，查一下这个文件的修改记录。这一下就锁定了第一次添加这个文件的哥们。然后我就试探性的发了个消息确认了下，至此真相大白了。
程序员的浪漫 私钥密码是这个开发人员女朋友的名字+生日组成的。创建的时候，他认为反正也不会有人用到密码，就决定埋这么一个彩蛋。
但他女朋友不是我们公司的，我不清楚他有没有告诉她。甚至，我都怀疑即使他告诉她这个浪漫的故事，她是否在完全听懂前就被前面那一大堆概念整懵了。
试想一下，服务器间每次建链时都要相互确认一下身份，都需要正确喊出她的名字才能通行。全球各地千万个机房里风扇轰鸣，机架上服务器网口灯快速闪烁着，这巨大的比特洪流都在默念着她的名字，不分昼夜。</description>
    </item>
    
    <item>
      <title>神经网络</title>
      <link>https://axiomaster.github.io/post/2019-01-21-neural-network/</link>
      <pubDate>Mon, 21 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-01-21-neural-network/</guid>
      <description>感知机 多层感知机 神经网络 </description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://axiomaster.github.io/post/2019-01-05-hello-world/</link>
      <pubDate>Sat, 05 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-01-05-hello-world/</guid>
      <description>我的Github Page开张了 突然发现github提供了page功能，简直太赞了。纯静态，使用markdown编写，支持绑定域名，不需要网络主机。。。这么多好处怎能拒绝呢？
有了page，还有什么理由不好好写博客，不好好记笔记呢？
现在开始，把之前博客上的零碎都搬过来，然后开始好好写博客。
致谢 本博客使用了柏荧(BY)的模板，在此向他致谢。</description>
    </item>
    
    <item>
      <title>docker 常用命令</title>
      <link>https://axiomaster.github.io/post/2018-05-27-docker-command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-05-27-docker-command/</guid>
      <description>docker 常用命令 重命名image </description>
    </item>
    
    <item>
      <title>go get 网络问题失败</title>
      <link>https://axiomaster.github.io/post/2018-05-06-go-get-xxx-failed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-05-06-go-get-xxx-failed/</guid>
      <description>go get 网络问题失败 使用go get golang.org/x获取包时，因为GWF问题导致下载失败。可以通过以下方法解决：
Comments lism: https://coolshell.cn/articles/9070.html
Bugsturb: Generally I don&amp;rsquo;t read article on blogs, but I wish to say that this write-up very forced me to try and do so! Your writing style has been amazed me. Thanks, very nice post.
Free auto approve list 7-27-2018: I added a new list. As you&amp;rsquo;ll see it&amp;rsquo;s bigger than most of them. I hope you all have had a great week!</description>
    </item>
    
    <item>
      <title>goodbye wordpress</title>
      <link>https://axiomaster.github.io/post/2019-01-17-goodbye-wordpress/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2019-01-17-goodbye-wordpress/</guid>
      <description>goodbye wordpress 就要把blog迁移到github pages上去了，</description>
    </item>
    
    <item>
      <title>Hello world!</title>
      <link>https://axiomaster.github.io/post/2018-03-04-hello-world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-03-04-hello-world/</guid>
      <description>Hello world! Welcome to WordPress. This is your first post. Edit or delete it, then start writing!
Comments A WordPress Commenter: Hi, this is a comment.
http://idmcrack.net: If you want to increase your familiarity just keep visiting this website and be updated with the most recent gossip posted here. http://idmcrack.net/
Plomberie Pro, Le Spécialiste Du Matériel, Tube Et Raccord: La plus accessible, c&amp;rsquo;est l&amp;rsquo;eau du robinet. http://kaeru-s.halfmoon.jp/01k001KK/nnzklfbkngrlkgnlkdf/cyawabbs.cgi/USER=Pieroweb?
prix robinetterie salle de bain: Un robinet mal fermé : gaspillage de l&amp;rsquo;eau garanti.</description>
    </item>
    
    <item>
      <title>HttpClient getContentLength()问题</title>
      <link>https://axiomaster.github.io/post/2018-04-17-httpclient-getcontentlength/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-04-17-httpclient-getcontentlength/</guid>
      <description>HttpClient getContentLength()问题 java中使用HttpClient的getContentLength方法获取相应体大小时，如果服务端进行了gzip压缩，响应中可能不包含Content-Length字段。该方法无效。</description>
    </item>
    
    <item>
      <title>Java内存泄漏分析</title>
      <link>https://axiomaster.github.io/post/2018-03-04-java-oom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-03-04-java-oom/</guid>
      <description>Java内存泄漏分析 Java内存泄漏分析</description>
    </item>
    
    <item>
      <title>linux perf tool</title>
      <link>https://axiomaster.github.io/post/2018-08-14-linux-perf-tool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-08-14-linux-perf-tool/</guid>
      <description>linux perf tool  </description>
    </item>
    
    <item>
      <title>linux-cpu</title>
      <link>https://axiomaster.github.io/post/2018-07-01-linux-cpu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-07-01-linux-cpu/</guid>
      <description>linux-cpu Linux CPU使用率</description>
    </item>
    
    <item>
      <title>n-sum问题</title>
      <link>https://axiomaster.github.io/post/2018-03-11-n-sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-03-11-n-sum/</guid>
      <description>n-sum问题 n-sum问题是指在一列数nums中，对给定target，寻找n个数相加之和为target。n-sum问题最简单的形式就是2-sum问题。</description>
    </item>
    
    <item>
      <title>nginx中proxy_next_upstream问题</title>
      <link>https://axiomaster.github.io/post/2018-06-04-nginx-proxy_next_upstream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-06-04-nginx-proxy_next_upstream/</guid>
      <description>nginx中proxy_next_upstream问题 nginx提供了proxy_next_upstream命令，当转发给一个后端失败时，配置proxy_next_upstream可以转发给下一个后端。下面是完整的描述。
Comments axiomaster_lism: 简直无力吐槽这个markdown编辑器出来的效果
Auwneviosy: online gambling casino gsn casino games slots for real money | https://casinorealmoney2018.us.org/ - casino online
PneuseShienidiz: online car insurance quotes cheap car insurance cheap car insurance quotes aaa car insurance | https://wecarinsurance.us.com/ - aarp car insurance https://wecarinsurance.us.com/ - car insurance quotes
Loans Online: loans with bad credit payday loans bad credit ace cash loans
Spotloan: loans loans loan with bad credit loans
Quick Loan: loans online payday loans no faxing loans loan for bad credit</description>
    </item>
    
    <item>
      <title>Nginx监听著名端口</title>
      <link>https://axiomaster.github.io/post/2018-03-04-nginxlisten-famous-port/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-03-04-nginxlisten-famous-port/</guid>
      <description>Nginx监听著名端口 Nginx监听著名端口</description>
    </item>
    
    <item>
      <title>Nginx证书校验</title>
      <link>https://axiomaster.github.io/post/2018-03-04-nginx-cert-verify/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-03-04-nginx-cert-verify/</guid>
      <description>Nginx证书校验 </description>
    </item>
    
    <item>
      <title>Nginx配置CRL</title>
      <link>https://axiomaster.github.io/post/2018-03-13-nginx-crl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-03-13-nginx-crl/</guid>
      <description>Nginx配置CRL Nginx配置crl时，如果使用多级CA构成的证书链，则crl中必须包含每一级CA对应的crl文件，否则nginx使用crl校验会失败。
Comments John: Hey webmaster</description>
    </item>
    
    <item>
      <title>TLS协议抓包分析</title>
      <link>https://axiomaster.github.io/post/2018-03-04-tls-tcpdump-analyses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-03-04-tls-tcpdump-analyses/</guid>
      <description>TLS协议抓包分析 </description>
    </item>
    
    <item>
      <title>udp in linux by c</title>
      <link>https://axiomaster.github.io/post/2018-08-11-udp-in-linux-by-c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-08-11-udp-in-linux-by-c/</guid>
      <description>udp in linux by c Linux编程之UDP SOCKET全攻略</description>
    </item>
    
    <item>
      <title>zookeeper</title>
      <link>https://axiomaster.github.io/post/2018-03-11-zookeeper/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-03-11-zookeeper/</guid>
      <description>zookeeper zookeeper </description>
    </item>
    
    <item>
      <title>使用iptables进行转发</title>
      <link>https://axiomaster.github.io/post/2018-03-06-iptables-nat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-03-06-iptables-nat/</guid>
      <description>使用iptables进行转发 </description>
    </item>
    
    <item>
      <title>使用openssl进行证书</title>
      <link>https://axiomaster.github.io/post/2018-04-17-openssl-crt-key/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-04-17-openssl-crt-key/</guid>
      <description>使用openssl进行证书 检测私钥，分别导出证书和私钥的publickey, 然后比对public key是否相等。</description>
    </item>
    
    <item>
      <title>使用patch更新源代码</title>
      <link>https://axiomaster.github.io/post/2018-03-04-update-code-with-patch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-03-04-update-code-with-patch/</guid>
      <description>使用patch更新源代码 使用patch更新源代码</description>
    </item>
    
    <item>
      <title>修改nginx代码支持从文件读取密文密码</title>
      <link>https://axiomaster.github.io/post/2018-04-17-ngx-read-pwd-from-file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-04-17-ngx-read-pwd-from-file/</guid>
      <description>修改nginx代码支持从文件读取密文密码 主要修改的是event模块下的ngx_event_openssl.c文件。将原来的密码字符串当做文件名来处理，然后使用nginx的读取文件功能，读出密码。</description>
    </item>
    
    <item>
      <title>好玩的linux小应用</title>
      <link>https://axiomaster.github.io/post/2018-03-10-funny-linux-app/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-03-10-funny-linux-app/</guid>
      <description>好玩的linux小应用 收集一些linux下好玩的应用 </description>
    </item>
    
    <item>
      <title>每日一槽</title>
      <link>https://axiomaster.github.io/post/2018-03-10-hehe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-03-10-hehe/</guid>
      <description>每日一槽  </description>
    </item>
    
    <item>
      <title>每日一槽</title>
      <link>https://axiomaster.github.io/post/2018-03-13-haha/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-03-13-haha/</guid>
      <description>每日一槽  </description>
    </item>
    
    <item>
      <title>每日一槽</title>
      <link>https://axiomaster.github.io/post/2018-04-17-jiaban/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-04-17-jiaban/</guid>
      <description>每日一槽 很多人加班多了之后，都会说自己心好累。</description>
    </item>
    
    <item>
      <title>每日吐槽</title>
      <link>https://axiomaster.github.io/post/2018-04-20-daily/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-04-20-daily/</guid>
      <description>每日吐槽 每天早上起床的之后，我都会面临一场战争，脑子里面两个小人之间的战争。
Comments axiomaster_lism: https://www.cnblogs.com/mYunYu/p/8892833.html</description>
    </item>
    
    <item>
      <title>每日吐槽</title>
      <link>https://axiomaster.github.io/post/2018-05-01-tucao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://axiomaster.github.io/post/2018-05-01-tucao/</guid>
      <description>每日吐槽 我坐在电脑前看书，我妈在边上不停的跟我说，xxx又结婚了，xxx家又生小孩了，xxx和xxx还真厉害，都生了双胞胎，还都是龙凤胎。。。</description>
    </item>
    
  </channel>
</rss>